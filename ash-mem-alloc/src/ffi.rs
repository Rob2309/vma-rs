/* automatically generated by rust-bindgen 0.69.4 */

#![allow(warnings)]

pub type VkBool32 = u32;
pub type VkDeviceSize = u64;
pub type VkFlags = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkBuffer_T {
    _unused: [u8; 0],
}
pub type VkBuffer = *mut VkBuffer_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImage_T {
    _unused: [u8; 0],
}
pub type VkImage = *mut VkImage_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkInstance_T {
    _unused: [u8; 0],
}
pub type VkInstance = *mut VkInstance_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDevice_T {
    _unused: [u8; 0],
}
pub type VkPhysicalDevice = *mut VkPhysicalDevice_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDevice_T {
    _unused: [u8; 0],
}
pub type VkDevice = *mut VkDevice_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkCommandBuffer_T {
    _unused: [u8; 0],
}
pub type VkCommandBuffer = *mut VkCommandBuffer_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDeviceMemory_T {
    _unused: [u8; 0],
}
pub type VkDeviceMemory = *mut VkDeviceMemory_T;
pub const VkResult_VK_SUCCESS: VkResult = 0;
pub const VkResult_VK_NOT_READY: VkResult = 1;
pub const VkResult_VK_TIMEOUT: VkResult = 2;
pub const VkResult_VK_EVENT_SET: VkResult = 3;
pub const VkResult_VK_EVENT_RESET: VkResult = 4;
pub const VkResult_VK_INCOMPLETE: VkResult = 5;
pub const VkResult_VK_ERROR_OUT_OF_HOST_MEMORY: VkResult = -1;
pub const VkResult_VK_ERROR_OUT_OF_DEVICE_MEMORY: VkResult = -2;
pub const VkResult_VK_ERROR_INITIALIZATION_FAILED: VkResult = -3;
pub const VkResult_VK_ERROR_DEVICE_LOST: VkResult = -4;
pub const VkResult_VK_ERROR_MEMORY_MAP_FAILED: VkResult = -5;
pub const VkResult_VK_ERROR_LAYER_NOT_PRESENT: VkResult = -6;
pub const VkResult_VK_ERROR_EXTENSION_NOT_PRESENT: VkResult = -7;
pub const VkResult_VK_ERROR_FEATURE_NOT_PRESENT: VkResult = -8;
pub const VkResult_VK_ERROR_INCOMPATIBLE_DRIVER: VkResult = -9;
pub const VkResult_VK_ERROR_TOO_MANY_OBJECTS: VkResult = -10;
pub const VkResult_VK_ERROR_FORMAT_NOT_SUPPORTED: VkResult = -11;
pub const VkResult_VK_ERROR_FRAGMENTED_POOL: VkResult = -12;
pub const VkResult_VK_ERROR_UNKNOWN: VkResult = -13;
pub const VkResult_VK_ERROR_OUT_OF_POOL_MEMORY: VkResult = -1000069000;
pub const VkResult_VK_ERROR_INVALID_EXTERNAL_HANDLE: VkResult = -1000072003;
pub const VkResult_VK_ERROR_FRAGMENTATION: VkResult = -1000161000;
pub const VkResult_VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS: VkResult = -1000257000;
pub const VkResult_VK_PIPELINE_COMPILE_REQUIRED: VkResult = 1000297000;
pub const VkResult_VK_ERROR_SURFACE_LOST_KHR: VkResult = -1000000000;
pub const VkResult_VK_ERROR_NATIVE_WINDOW_IN_USE_KHR: VkResult = -1000000001;
pub const VkResult_VK_SUBOPTIMAL_KHR: VkResult = 1000001003;
pub const VkResult_VK_ERROR_OUT_OF_DATE_KHR: VkResult = -1000001004;
pub const VkResult_VK_ERROR_INCOMPATIBLE_DISPLAY_KHR: VkResult = -1000003001;
pub const VkResult_VK_ERROR_VALIDATION_FAILED_EXT: VkResult = -1000011001;
pub const VkResult_VK_ERROR_INVALID_SHADER_NV: VkResult = -1000012000;
pub const VkResult_VK_ERROR_IMAGE_USAGE_NOT_SUPPORTED_KHR: VkResult = -1000023000;
pub const VkResult_VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR: VkResult = -1000023001;
pub const VkResult_VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR: VkResult = -1000023002;
pub const VkResult_VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR: VkResult = -1000023003;
pub const VkResult_VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR: VkResult = -1000023004;
pub const VkResult_VK_ERROR_VIDEO_STD_VERSION_NOT_SUPPORTED_KHR: VkResult = -1000023005;
pub const VkResult_VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT: VkResult = -1000158000;
pub const VkResult_VK_ERROR_NOT_PERMITTED_KHR: VkResult = -1000174001;
pub const VkResult_VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT: VkResult = -1000255000;
pub const VkResult_VK_THREAD_IDLE_KHR: VkResult = 1000268000;
pub const VkResult_VK_THREAD_DONE_KHR: VkResult = 1000268001;
pub const VkResult_VK_OPERATION_DEFERRED_KHR: VkResult = 1000268002;
pub const VkResult_VK_OPERATION_NOT_DEFERRED_KHR: VkResult = 1000268003;
pub const VkResult_VK_ERROR_INVALID_VIDEO_STD_PARAMETERS_KHR: VkResult = -1000299000;
pub const VkResult_VK_ERROR_COMPRESSION_EXHAUSTED_EXT: VkResult = -1000338000;
pub const VkResult_VK_INCOMPATIBLE_SHADER_BINARY_EXT: VkResult = 1000482000;
pub const VkResult_VK_ERROR_OUT_OF_POOL_MEMORY_KHR: VkResult = -1000069000;
pub const VkResult_VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR: VkResult = -1000072003;
pub const VkResult_VK_ERROR_FRAGMENTATION_EXT: VkResult = -1000161000;
pub const VkResult_VK_ERROR_NOT_PERMITTED_EXT: VkResult = -1000174001;
pub const VkResult_VK_ERROR_INVALID_DEVICE_ADDRESS_EXT: VkResult = -1000257000;
pub const VkResult_VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR: VkResult = -1000257000;
pub const VkResult_VK_PIPELINE_COMPILE_REQUIRED_EXT: VkResult = 1000297000;
pub const VkResult_VK_ERROR_PIPELINE_COMPILE_REQUIRED_EXT: VkResult = 1000297000;
pub const VkResult_VK_ERROR_INCOMPATIBLE_SHADER_BINARY_EXT: VkResult = 1000482000;
pub const VkResult_VK_RESULT_MAX_ENUM: VkResult = 2147483647;
pub type VkResult = ::std::os::raw::c_int;
pub const VkStructureType_VK_STRUCTURE_TYPE_APPLICATION_INFO: VkStructureType = 0;
pub const VkStructureType_VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO: VkStructureType = 1;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO: VkStructureType = 2;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO: VkStructureType = 3;
pub const VkStructureType_VK_STRUCTURE_TYPE_SUBMIT_INFO: VkStructureType = 4;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO: VkStructureType = 5;
pub const VkStructureType_VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE: VkStructureType = 6;
pub const VkStructureType_VK_STRUCTURE_TYPE_BIND_SPARSE_INFO: VkStructureType = 7;
pub const VkStructureType_VK_STRUCTURE_TYPE_FENCE_CREATE_INFO: VkStructureType = 8;
pub const VkStructureType_VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO: VkStructureType = 9;
pub const VkStructureType_VK_STRUCTURE_TYPE_EVENT_CREATE_INFO: VkStructureType = 10;
pub const VkStructureType_VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO: VkStructureType = 11;
pub const VkStructureType_VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO: VkStructureType = 12;
pub const VkStructureType_VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO: VkStructureType = 13;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO: VkStructureType = 14;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO: VkStructureType = 15;
pub const VkStructureType_VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO: VkStructureType = 16;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO: VkStructureType = 17;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO: VkStructureType = 18;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO:
    VkStructureType = 19;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO:
    VkStructureType = 20;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO:
    VkStructureType = 21;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO: VkStructureType =
    22;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO:
    VkStructureType = 23;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO:
    VkStructureType = 24;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO:
    VkStructureType = 25;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO:
    VkStructureType = 26;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO: VkStructureType =
    27;
pub const VkStructureType_VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO: VkStructureType = 28;
pub const VkStructureType_VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO: VkStructureType = 29;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO: VkStructureType = 30;
pub const VkStructureType_VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO: VkStructureType = 31;
pub const VkStructureType_VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO: VkStructureType = 32;
pub const VkStructureType_VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO: VkStructureType = 33;
pub const VkStructureType_VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO: VkStructureType = 34;
pub const VkStructureType_VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET: VkStructureType = 35;
pub const VkStructureType_VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET: VkStructureType = 36;
pub const VkStructureType_VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO: VkStructureType = 37;
pub const VkStructureType_VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO: VkStructureType = 38;
pub const VkStructureType_VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO: VkStructureType = 39;
pub const VkStructureType_VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO: VkStructureType = 40;
pub const VkStructureType_VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO: VkStructureType = 41;
pub const VkStructureType_VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO: VkStructureType = 42;
pub const VkStructureType_VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO: VkStructureType = 43;
pub const VkStructureType_VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER: VkStructureType = 44;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER: VkStructureType = 45;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_BARRIER: VkStructureType = 46;
pub const VkStructureType_VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO: VkStructureType = 47;
pub const VkStructureType_VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO: VkStructureType = 48;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES: VkStructureType =
    1000094000;
pub const VkStructureType_VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO: VkStructureType = 1000157000;
pub const VkStructureType_VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO: VkStructureType = 1000157001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES:
    VkStructureType = 1000083000;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS: VkStructureType =
    1000127000;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO: VkStructureType =
    1000127001;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO: VkStructureType =
    1000060000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO: VkStructureType =
    1000060003;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO:
    VkStructureType = 1000060004;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO: VkStructureType = 1000060005;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO: VkStructureType =
    1000060006;
pub const VkStructureType_VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO: VkStructureType =
    1000060013;
pub const VkStructureType_VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO: VkStructureType =
    1000060014;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES: VkStructureType =
    1000070000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO: VkStructureType =
    1000070001;
pub const VkStructureType_VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2: VkStructureType =
    1000146000;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2: VkStructureType =
    1000146001;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2:
    VkStructureType = 1000146002;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2: VkStructureType = 1000146003;
pub const VkStructureType_VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2: VkStructureType =
    1000146004;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2: VkStructureType =
    1000059000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2: VkStructureType =
    1000059001;
pub const VkStructureType_VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2: VkStructureType = 1000059002;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2: VkStructureType = 1000059003;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2: VkStructureType =
    1000059004;
pub const VkStructureType_VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2: VkStructureType = 1000059005;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2: VkStructureType =
    1000059006;
pub const VkStructureType_VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2: VkStructureType =
    1000059007;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2:
    VkStructureType = 1000059008;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES:
    VkStructureType = 1000117000;
pub const VkStructureType_VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO:
    VkStructureType = 1000117001;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO: VkStructureType =
    1000117002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO : VkStructureType = 1000117003 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO: VkStructureType =
    1000053000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES: VkStructureType =
    1000053001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES: VkStructureType =
    1000053002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES:
    VkStructureType = 1000120000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO: VkStructureType = 1000145000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES:
    VkStructureType = 1000145001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES:
    VkStructureType = 1000145002;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2: VkStructureType = 1000145003;
pub const VkStructureType_VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO: VkStructureType =
    1000156000;
pub const VkStructureType_VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO: VkStructureType =
    1000156001;
pub const VkStructureType_VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO: VkStructureType =
    1000156002;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO: VkStructureType =
    1000156003;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES:
    VkStructureType = 1000156004;
pub const VkStructureType_VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES:
    VkStructureType = 1000156005;
pub const VkStructureType_VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO:
    VkStructureType = 1000085000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO:
    VkStructureType = 1000071000;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES: VkStructureType =
    1000071001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO: VkStructureType =
    1000071002;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES: VkStructureType =
    1000071003;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES: VkStructureType =
    1000071004;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO: VkStructureType =
    1000072000;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO: VkStructureType =
    1000072001;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO: VkStructureType =
    1000072002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO: VkStructureType =
    1000112000;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES: VkStructureType = 1000112001;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO: VkStructureType = 1000113000;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO: VkStructureType =
    1000077000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO:
    VkStructureType = 1000076000;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES: VkStructureType =
    1000076001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES:
    VkStructureType = 1000168000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT: VkStructureType =
    1000168001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES:
    VkStructureType = 1000063000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES: VkStructureType =
    49;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES: VkStructureType =
    50;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES: VkStructureType =
    51;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES: VkStructureType =
    52;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO: VkStructureType =
    1000147000;
pub const VkStructureType_VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2: VkStructureType = 1000109000;
pub const VkStructureType_VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2: VkStructureType = 1000109001;
pub const VkStructureType_VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2: VkStructureType = 1000109002;
pub const VkStructureType_VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2: VkStructureType = 1000109003;
pub const VkStructureType_VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2: VkStructureType = 1000109004;
pub const VkStructureType_VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO: VkStructureType = 1000109005;
pub const VkStructureType_VK_STRUCTURE_TYPE_SUBPASS_END_INFO: VkStructureType = 1000109006;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES: VkStructureType =
    1000177000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES: VkStructureType =
    1000196000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES:
    VkStructureType = 1000180000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES:
    VkStructureType = 1000082000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES:
    VkStructureType = 1000197000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO:
    VkStructureType = 1000161000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES:
    VkStructureType = 1000161001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES:
    VkStructureType = 1000161002;
pub const VkStructureType_VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO : VkStructureType = 1000161003 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT : VkStructureType = 1000161004 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES:
    VkStructureType = 1000199000;
pub const VkStructureType_VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE:
    VkStructureType = 1000199001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES:
    VkStructureType = 1000221000;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO: VkStructureType =
    1000246000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES:
    VkStructureType = 1000130000;
pub const VkStructureType_VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO: VkStructureType =
    1000130001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES:
    VkStructureType = 1000211000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES:
    VkStructureType = 1000108000;
pub const VkStructureType_VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO: VkStructureType =
    1000108001;
pub const VkStructureType_VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO: VkStructureType =
    1000108002;
pub const VkStructureType_VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO: VkStructureType =
    1000108003;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES : VkStructureType = 1000253000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES : VkStructureType = 1000175000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES : VkStructureType = 1000241000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT: VkStructureType =
    1000241001;
pub const VkStructureType_VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT: VkStructureType =
    1000241002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES:
    VkStructureType = 1000261000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES:
    VkStructureType = 1000207000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES:
    VkStructureType = 1000207001;
pub const VkStructureType_VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO: VkStructureType =
    1000207002;
pub const VkStructureType_VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO: VkStructureType =
    1000207003;
pub const VkStructureType_VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO: VkStructureType = 1000207004;
pub const VkStructureType_VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO: VkStructureType = 1000207005;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES:
    VkStructureType = 1000257000;
pub const VkStructureType_VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO: VkStructureType =
    1000244001;
pub const VkStructureType_VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO:
    VkStructureType = 1000257002;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO:
    VkStructureType = 1000257003;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO:
    VkStructureType = 1000257004;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES: VkStructureType =
    53;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES: VkStructureType =
    54;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO:
    VkStructureType = 1000192000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES:
    VkStructureType = 1000215000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES: VkStructureType =
    1000245000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES : VkStructureType = 1000276000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES: VkStructureType =
    1000295000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO: VkStructureType =
    1000295001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO: VkStructureType =
    1000295002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES : VkStructureType = 1000297000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_BARRIER_2: VkStructureType = 1000314000;
pub const VkStructureType_VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2: VkStructureType = 1000314001;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2: VkStructureType = 1000314002;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEPENDENCY_INFO: VkStructureType = 1000314003;
pub const VkStructureType_VK_STRUCTURE_TYPE_SUBMIT_INFO_2: VkStructureType = 1000314004;
pub const VkStructureType_VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO: VkStructureType = 1000314005;
pub const VkStructureType_VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO: VkStructureType =
    1000314006;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES:
    VkStructureType = 1000314007;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES : VkStructureType = 1000325000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES:
    VkStructureType = 1000335000;
pub const VkStructureType_VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2: VkStructureType = 1000337000;
pub const VkStructureType_VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2: VkStructureType = 1000337001;
pub const VkStructureType_VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2: VkStructureType =
    1000337002;
pub const VkStructureType_VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2: VkStructureType =
    1000337003;
pub const VkStructureType_VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2: VkStructureType = 1000337004;
pub const VkStructureType_VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2: VkStructureType = 1000337005;
pub const VkStructureType_VK_STRUCTURE_TYPE_BUFFER_COPY_2: VkStructureType = 1000337006;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_COPY_2: VkStructureType = 1000337007;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_BLIT_2: VkStructureType = 1000337008;
pub const VkStructureType_VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2: VkStructureType = 1000337009;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2: VkStructureType = 1000337010;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES:
    VkStructureType = 1000225000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO : VkStructureType = 1000225001 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES:
    VkStructureType = 1000225002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES:
    VkStructureType = 1000138000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES:
    VkStructureType = 1000138001;
pub const VkStructureType_VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK:
    VkStructureType = 1000138002;
pub const VkStructureType_VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO:
    VkStructureType = 1000138003;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES : VkStructureType = 1000066000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_RENDERING_INFO: VkStructureType = 1000044000;
pub const VkStructureType_VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO: VkStructureType = 1000044001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO: VkStructureType =
    1000044002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES:
    VkStructureType = 1000044003;
pub const VkStructureType_VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO:
    VkStructureType = 1000044004;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES:
    VkStructureType = 1000280000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES : VkStructureType = 1000280001 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES:
    VkStructureType = 1000281001;
pub const VkStructureType_VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3: VkStructureType = 1000360000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES:
    VkStructureType = 1000413000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES:
    VkStructureType = 1000413001;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS: VkStructureType =
    1000413002;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS: VkStructureType =
    1000413003;
pub const VkStructureType_VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR: VkStructureType = 1000001000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PRESENT_INFO_KHR: VkStructureType = 1000001001;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR: VkStructureType =
    1000060007;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR: VkStructureType =
    1000060008;
pub const VkStructureType_VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR: VkStructureType =
    1000060009;
pub const VkStructureType_VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR: VkStructureType =
    1000060010;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR: VkStructureType =
    1000060011;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR:
    VkStructureType = 1000060012;
pub const VkStructureType_VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR: VkStructureType =
    1000002000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR: VkStructureType =
    1000002001;
pub const VkStructureType_VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR: VkStructureType = 1000003000;
pub const VkStructureType_VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR: VkStructureType =
    1000004000;
pub const VkStructureType_VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR: VkStructureType =
    1000005000;
pub const VkStructureType_VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR: VkStructureType =
    1000006000;
pub const VkStructureType_VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR: VkStructureType =
    1000008000;
pub const VkStructureType_VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR: VkStructureType =
    1000009000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT: VkStructureType =
    1000011000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD:
    VkStructureType = 1000018000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT: VkStructureType =
    1000022000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT: VkStructureType =
    1000022001;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT: VkStructureType =
    1000022002;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR: VkStructureType = 1000023000;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR: VkStructureType = 1000023001;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR: VkStructureType =
    1000023002;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_SESSION_MEMORY_REQUIREMENTS_KHR: VkStructureType =
    1000023003;
pub const VkStructureType_VK_STRUCTURE_TYPE_BIND_VIDEO_SESSION_MEMORY_INFO_KHR: VkStructureType =
    1000023004;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR: VkStructureType =
    1000023005;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR:
    VkStructureType = 1000023006;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR:
    VkStructureType = 1000023007;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR: VkStructureType =
    1000023008;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR: VkStructureType = 1000023009;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR: VkStructureType =
    1000023010;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR: VkStructureType =
    1000023011;
pub const VkStructureType_VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR: VkStructureType =
    1000023012;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR: VkStructureType =
    1000023013;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR: VkStructureType =
    1000023014;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR: VkStructureType =
    1000023015;
pub const VkStructureType_VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR:
    VkStructureType = 1000023016;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR: VkStructureType = 1000024000;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR: VkStructureType =
    1000024001;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR: VkStructureType =
    1000024002;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV:
    VkStructureType = 1000026000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV:
    VkStructureType = 1000026001;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV:
    VkStructureType = 1000026002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT:
    VkStructureType = 1000028000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT:
    VkStructureType = 1000028001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT:
    VkStructureType = 1000028002;
pub const VkStructureType_VK_STRUCTURE_TYPE_CU_MODULE_CREATE_INFO_NVX: VkStructureType = 1000029000;
pub const VkStructureType_VK_STRUCTURE_TYPE_CU_FUNCTION_CREATE_INFO_NVX: VkStructureType =
    1000029001;
pub const VkStructureType_VK_STRUCTURE_TYPE_CU_LAUNCH_INFO_NVX: VkStructureType = 1000029002;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX: VkStructureType =
    1000030000;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX: VkStructureType =
    1000030001;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_KHR: VkStructureType =
    1000038000;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR:
    VkStructureType = 1000038001;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR:
    VkStructureType = 1000038002;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PICTURE_INFO_KHR: VkStructureType =
    1000038003;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_KHR: VkStructureType =
    1000038004;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_NALU_SLICE_INFO_KHR: VkStructureType =
    1000038005;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_GOP_REMAINING_FRAME_INFO_KHR:
    VkStructureType = 1000038006;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_KHR: VkStructureType =
    1000038007;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_KHR:
    VkStructureType = 1000038008;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_LAYER_INFO_KHR:
    VkStructureType = 1000038009;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_CREATE_INFO_KHR:
    VkStructureType = 1000038010;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUALITY_LEVEL_PROPERTIES_KHR:
    VkStructureType = 1000038011;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_GET_INFO_KHR:
    VkStructureType = 1000038012;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_FEEDBACK_INFO_KHR : VkStructureType = 1000038013 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_CAPABILITIES_KHR: VkStructureType =
    1000039000;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR:
    VkStructureType = 1000039001;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR:
    VkStructureType = 1000039002;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PICTURE_INFO_KHR: VkStructureType =
    1000039003;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_KHR: VkStructureType =
    1000039004;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_NALU_SLICE_SEGMENT_INFO_KHR:
    VkStructureType = 1000039005;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_GOP_REMAINING_FRAME_INFO_KHR:
    VkStructureType = 1000039006;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_INFO_KHR: VkStructureType =
    1000039007;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_INFO_KHR:
    VkStructureType = 1000039009;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_LAYER_INFO_KHR:
    VkStructureType = 1000039010;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_CREATE_INFO_KHR:
    VkStructureType = 1000039011;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUALITY_LEVEL_PROPERTIES_KHR:
    VkStructureType = 1000039012;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_GET_INFO_KHR:
    VkStructureType = 1000039013;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_FEEDBACK_INFO_KHR : VkStructureType = 1000039014 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_KHR: VkStructureType =
    1000040000;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_KHR: VkStructureType =
    1000040001;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR: VkStructureType =
    1000040003;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR:
    VkStructureType = 1000040004;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR:
    VkStructureType = 1000040005;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR: VkStructureType =
    1000040006;
pub const VkStructureType_VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD:
    VkStructureType = 1000041000;
pub const VkStructureType_VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR:
    VkStructureType = 1000044006;
pub const VkStructureType_VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT:
    VkStructureType = 1000044007;
pub const VkStructureType_VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD: VkStructureType =
    1000044008;
pub const VkStructureType_VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX:
    VkStructureType = 1000044009;
pub const VkStructureType_VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP:
    VkStructureType = 1000049000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV:
    VkStructureType = 1000050000;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV: VkStructureType =
    1000056000;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV: VkStructureType =
    1000056001;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV: VkStructureType =
    1000057000;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV: VkStructureType =
    1000057001;
pub const VkStructureType_VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV:
    VkStructureType = 1000058000;
pub const VkStructureType_VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT: VkStructureType = 1000061000;
pub const VkStructureType_VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN: VkStructureType = 1000062000;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT: VkStructureType =
    1000067000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT:
    VkStructureType = 1000067001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT: VkStructureType =
    1000068000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES_EXT:
    VkStructureType = 1000068001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES_EXT:
    VkStructureType = 1000068002;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR: VkStructureType =
    1000073000;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR: VkStructureType =
    1000073001;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR: VkStructureType =
    1000073002;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR: VkStructureType =
    1000073003;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR: VkStructureType = 1000074000;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR: VkStructureType = 1000074001;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR: VkStructureType = 1000074002;
pub const VkStructureType_VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR:
    VkStructureType = 1000075000;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR:
    VkStructureType = 1000078000;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR:
    VkStructureType = 1000078001;
pub const VkStructureType_VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR: VkStructureType =
    1000078002;
pub const VkStructureType_VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR: VkStructureType =
    1000078003;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR: VkStructureType =
    1000079000;
pub const VkStructureType_VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR: VkStructureType = 1000079001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR:
    VkStructureType = 1000080000;
pub const VkStructureType_VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT : VkStructureType = 1000081000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT:
    VkStructureType = 1000081001;
pub const VkStructureType_VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT: VkStructureType =
    1000081002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR: VkStructureType = 1000084000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV:
    VkStructureType = 1000087000;
pub const VkStructureType_VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT: VkStructureType =
    1000090000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT: VkStructureType = 1000091000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT: VkStructureType = 1000091001;
pub const VkStructureType_VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT: VkStructureType = 1000091002;
pub const VkStructureType_VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT: VkStructureType =
    1000091003;
pub const VkStructureType_VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE: VkStructureType = 1000092000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX : VkStructureType = 1000097000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV:
    VkStructureType = 1000098000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT:
    VkStructureType = 1000099000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT:
    VkStructureType = 1000099001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT : VkStructureType = 1000101000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT : VkStructureType = 1000101001 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT:
    VkStructureType = 1000102000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT : VkStructureType = 1000102001 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_HDR_METADATA_EXT: VkStructureType = 1000105000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RELAXED_LINE_RASTERIZATION_FEATURES_IMG : VkStructureType = 1000110000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR:
    VkStructureType = 1000111000;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR: VkStructureType =
    1000114000;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR: VkStructureType =
    1000114001;
pub const VkStructureType_VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR: VkStructureType =
    1000114002;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR: VkStructureType = 1000115000;
pub const VkStructureType_VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR: VkStructureType = 1000115001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR:
    VkStructureType = 1000116000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR:
    VkStructureType = 1000116001;
pub const VkStructureType_VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR:
    VkStructureType = 1000116002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR: VkStructureType =
    1000116003;
pub const VkStructureType_VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR: VkStructureType =
    1000116004;
pub const VkStructureType_VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR: VkStructureType = 1000116005;
pub const VkStructureType_VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR: VkStructureType =
    1000116006;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR: VkStructureType =
    1000119000;
pub const VkStructureType_VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR: VkStructureType =
    1000119001;
pub const VkStructureType_VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR: VkStructureType = 1000119002;
pub const VkStructureType_VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR: VkStructureType = 1000121000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR: VkStructureType =
    1000121001;
pub const VkStructureType_VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR: VkStructureType =
    1000121002;
pub const VkStructureType_VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR: VkStructureType = 1000121003;
pub const VkStructureType_VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR: VkStructureType =
    1000121004;
pub const VkStructureType_VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK: VkStructureType =
    1000122000;
pub const VkStructureType_VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK: VkStructureType =
    1000123000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT: VkStructureType =
    1000128000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT: VkStructureType =
    1000128001;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT: VkStructureType = 1000128002;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT:
    VkStructureType = 1000128003;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT: VkStructureType =
    1000128004;
pub const VkStructureType_VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID: VkStructureType =
    1000129000;
pub const VkStructureType_VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID:
    VkStructureType = 1000129001;
pub const VkStructureType_VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID:
    VkStructureType = 1000129002;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID:
    VkStructureType = 1000129003;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID:
    VkStructureType = 1000129004;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID: VkStructureType = 1000129005;
pub const VkStructureType_VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID:
    VkStructureType = 1000129006;
pub const VkStructureType_VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT: VkStructureType = 1000143000;
pub const VkStructureType_VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT:
    VkStructureType = 1000143001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT:
    VkStructureType = 1000143002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT:
    VkStructureType = 1000143003;
pub const VkStructureType_VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT: VkStructureType =
    1000143004;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT : VkStructureType = 1000148000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT : VkStructureType = 1000148001 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT:
    VkStructureType = 1000148002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV:
    VkStructureType = 1000149000;
pub const VkStructureType_VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR:
    VkStructureType = 1000150007;
pub const VkStructureType_VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR:
    VkStructureType = 1000150000;
pub const VkStructureType_VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR:
    VkStructureType = 1000150002;
pub const VkStructureType_VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR:
    VkStructureType = 1000150003;
pub const VkStructureType_VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR:
    VkStructureType = 1000150004;
pub const VkStructureType_VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR:
    VkStructureType = 1000150005;
pub const VkStructureType_VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR: VkStructureType =
    1000150006;
pub const VkStructureType_VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR:
    VkStructureType = 1000150009;
pub const VkStructureType_VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR: VkStructureType =
    1000150010;
pub const VkStructureType_VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR:
    VkStructureType = 1000150011;
pub const VkStructureType_VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR:
    VkStructureType = 1000150012;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR:
    VkStructureType = 1000150013;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR : VkStructureType = 1000150014 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR:
    VkStructureType = 1000150017;
pub const VkStructureType_VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR:
    VkStructureType = 1000150020;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR:
    VkStructureType = 1000347000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR:
    VkStructureType = 1000347001;
pub const VkStructureType_VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR: VkStructureType =
    1000150015;
pub const VkStructureType_VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR:
    VkStructureType = 1000150016;
pub const VkStructureType_VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR:
    VkStructureType = 1000150018;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR:
    VkStructureType = 1000348013;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV:
    VkStructureType = 1000152000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV:
    VkStructureType = 1000154000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV:
    VkStructureType = 1000154001;
pub const VkStructureType_VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT:
    VkStructureType = 1000158000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT:
    VkStructureType = 1000158002;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT:
    VkStructureType = 1000158003;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT:
    VkStructureType = 1000158004;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT:
    VkStructureType = 1000158005;
pub const VkStructureType_VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT:
    VkStructureType = 1000158006;
pub const VkStructureType_VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT: VkStructureType =
    1000160000;
pub const VkStructureType_VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT:
    VkStructureType = 1000160001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV : VkStructureType = 1000164000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV:
    VkStructureType = 1000164001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV:
    VkStructureType = 1000164002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV : VkStructureType = 1000164005 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV: VkStructureType =
    1000165000;
pub const VkStructureType_VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV: VkStructureType =
    1000165001;
pub const VkStructureType_VK_STRUCTURE_TYPE_GEOMETRY_NV: VkStructureType = 1000165003;
pub const VkStructureType_VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV: VkStructureType = 1000165004;
pub const VkStructureType_VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV: VkStructureType = 1000165005;
pub const VkStructureType_VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV:
    VkStructureType = 1000165006;
pub const VkStructureType_VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV:
    VkStructureType = 1000165007;
pub const VkStructureType_VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV:
    VkStructureType = 1000165008;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV:
    VkStructureType = 1000165009;
pub const VkStructureType_VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV:
    VkStructureType = 1000165011;
pub const VkStructureType_VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV: VkStructureType =
    1000165012;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV : VkStructureType = 1000166000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV : VkStructureType = 1000166001 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT:
    VkStructureType = 1000170000;
pub const VkStructureType_VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT:
    VkStructureType = 1000170001;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT: VkStructureType =
    1000178000;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT: VkStructureType =
    1000178001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT:
    VkStructureType = 1000178002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR:
    VkStructureType = 1000181000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD:
    VkStructureType = 1000183000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD:
    VkStructureType = 1000185000;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_KHR: VkStructureType =
    1000187000;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR:
    VkStructureType = 1000187001;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR:
    VkStructureType = 1000187002;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_KHR: VkStructureType =
    1000187003;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_KHR: VkStructureType =
    1000187004;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR: VkStructureType =
    1000187005;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR:
    VkStructureType = 1000174000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR:
    VkStructureType = 1000388000;
pub const VkStructureType_VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR:
    VkStructureType = 1000388001;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD:
    VkStructureType = 1000189000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT : VkStructureType = 1000190000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP: VkStructureType = 1000191000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV : VkStructureType = 1000201000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV:
    VkStructureType = 1000202000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV:
    VkStructureType = 1000202001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV:
    VkStructureType = 1000204000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV : VkStructureType = 1000205000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV:
    VkStructureType = 1000205002;
pub const VkStructureType_VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV: VkStructureType = 1000206000;
pub const VkStructureType_VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV: VkStructureType =
    1000206001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL : VkStructureType = 1000209000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL:
    VkStructureType = 1000210000;
pub const VkStructureType_VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL: VkStructureType =
    1000210001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL: VkStructureType =
    1000210002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL: VkStructureType =
    1000210003;
pub const VkStructureType_VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL: VkStructureType =
    1000210004;
pub const VkStructureType_VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL:
    VkStructureType = 1000210005;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT:
    VkStructureType = 1000212000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD:
    VkStructureType = 1000213000;
pub const VkStructureType_VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD:
    VkStructureType = 1000213001;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA: VkStructureType =
    1000214000;
pub const VkStructureType_VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT: VkStructureType =
    1000217000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT:
    VkStructureType = 1000218000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT:
    VkStructureType = 1000218001;
pub const VkStructureType_VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT:
    VkStructureType = 1000218002;
pub const VkStructureType_VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR:
    VkStructureType = 1000226000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR:
    VkStructureType = 1000226001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR:
    VkStructureType = 1000226002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR:
    VkStructureType = 1000226003;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR:
    VkStructureType = 1000226004;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD:
    VkStructureType = 1000227000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD:
    VkStructureType = 1000229000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES_KHR : VkStructureType = 1000232000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO_KHR:
    VkStructureType = 1000232001;
pub const VkStructureType_VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO_KHR:
    VkStructureType = 1000232002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT : VkStructureType = 1000234000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_QUAD_CONTROL_FEATURES_KHR:
    VkStructureType = 1000235000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT:
    VkStructureType = 1000237000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT:
    VkStructureType = 1000238000;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT: VkStructureType =
    1000238001;
pub const VkStructureType_VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR: VkStructureType =
    1000239000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV : VkStructureType = 1000240000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT:
    VkStructureType = 1000244000;
pub const VkStructureType_VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT: VkStructureType =
    1000244002;
pub const VkStructureType_VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT: VkStructureType = 1000247000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR:
    VkStructureType = 1000248000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV:
    VkStructureType = 1000249000;
pub const VkStructureType_VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV: VkStructureType =
    1000249001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV:
    VkStructureType = 1000249002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV:
    VkStructureType = 1000250000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV:
    VkStructureType = 1000250001;
pub const VkStructureType_VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV:
    VkStructureType = 1000250002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT : VkStructureType = 1000251000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT:
    VkStructureType = 1000252000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT:
    VkStructureType = 1000254000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT : VkStructureType = 1000254001 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT:
    VkStructureType = 1000254002;
pub const VkStructureType_VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT:
    VkStructureType = 1000255000;
pub const VkStructureType_VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT:
    VkStructureType = 1000255002;
pub const VkStructureType_VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT:
    VkStructureType = 1000255001;
pub const VkStructureType_VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT: VkStructureType =
    1000256000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT:
    VkStructureType = 1000260000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT:
    VkStructureType = 1000267000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR : VkStructureType = 1000269000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR: VkStructureType = 1000269001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR: VkStructureType =
    1000269002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR: VkStructureType =
    1000269003;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR: VkStructureType =
    1000269004;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR:
    VkStructureType = 1000269005;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES_EXT:
    VkStructureType = 1000270000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES_EXT:
    VkStructureType = 1000270001;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY_EXT: VkStructureType = 1000270002;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY_EXT: VkStructureType = 1000270003;
pub const VkStructureType_VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO_EXT: VkStructureType =
    1000270004;
pub const VkStructureType_VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO_EXT: VkStructureType =
    1000270005;
pub const VkStructureType_VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO_EXT: VkStructureType =
    1000270006;
pub const VkStructureType_VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO_EXT: VkStructureType =
    1000270007;
pub const VkStructureType_VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE_EXT: VkStructureType =
    1000270008;
pub const VkStructureType_VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY_EXT:
    VkStructureType = 1000270009;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_MAP_INFO_KHR: VkStructureType = 1000271000;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO_KHR: VkStructureType = 1000271001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_FEATURES_EXT:
    VkStructureType = 1000272000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_PROPERTIES_EXT:
    VkStructureType = 1000272001;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_MAP_PLACED_INFO_EXT: VkStructureType =
    1000272002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT:
    VkStructureType = 1000273000;
pub const VkStructureType_VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_EXT: VkStructureType = 1000274000;
pub const VkStructureType_VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_EXT:
    VkStructureType = 1000274001;
pub const VkStructureType_VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_EXT:
    VkStructureType = 1000274002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_EXT:
    VkStructureType = 1000275000;
pub const VkStructureType_VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_EXT: VkStructureType =
    1000275001;
pub const VkStructureType_VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_EXT:
    VkStructureType = 1000275002;
pub const VkStructureType_VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_EXT: VkStructureType =
    1000275003;
pub const VkStructureType_VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_EXT:
    VkStructureType = 1000275004;
pub const VkStructureType_VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_EXT: VkStructureType =
    1000275005;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV : VkStructureType = 1000277000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV: VkStructureType =
    1000277001;
pub const VkStructureType_VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV:
    VkStructureType = 1000277002;
pub const VkStructureType_VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV: VkStructureType =
    1000277003;
pub const VkStructureType_VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV:
    VkStructureType = 1000277004;
pub const VkStructureType_VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV: VkStructureType =
    1000277005;
pub const VkStructureType_VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV:
    VkStructureType = 1000277006;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV : VkStructureType = 1000277007 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV : VkStructureType = 1000278000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV:
    VkStructureType = 1000278001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT:
    VkStructureType = 1000281000;
pub const VkStructureType_VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM : VkStructureType = 1000282000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM: VkStructureType =
    1000282001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT:
    VkStructureType = 1000283000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEPTH_BIAS_INFO_EXT: VkStructureType = 1000283001;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT: VkStructureType =
    1000283002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT:
    VkStructureType = 1000284000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT:
    VkStructureType = 1000284001;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT:
    VkStructureType = 1000284002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT:
    VkStructureType = 1000286000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT:
    VkStructureType = 1000286001;
pub const VkStructureType_VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT:
    VkStructureType = 1000287000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT:
    VkStructureType = 1000287001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT:
    VkStructureType = 1000287002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR: VkStructureType =
    1000290000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV:
    VkStructureType = 1000292000;
pub const VkStructureType_VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV:
    VkStructureType = 1000292001;
pub const VkStructureType_VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV:
    VkStructureType = 1000292002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PRESENT_ID_KHR: VkStructureType = 1000294000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR:
    VkStructureType = 1000294001;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR: VkStructureType = 1000299000;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR: VkStructureType =
    1000299001;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR:
    VkStructureType = 1000299002;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR: VkStructureType =
    1000299003;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR: VkStructureType =
    1000299004;
pub const VkStructureType_VK_STRUCTURE_TYPE_QUERY_POOL_VIDEO_ENCODE_FEEDBACK_CREATE_INFO_KHR:
    VkStructureType = 1000299005;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR:
    VkStructureType = 1000299006;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_PROPERTIES_KHR:
    VkStructureType = 1000299007;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR: VkStructureType =
    1000299008;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_GET_INFO_KHR:
    VkStructureType = 1000299009;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_FEEDBACK_INFO_KHR:
    VkStructureType = 1000299010;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV:
    VkStructureType = 1000300000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV:
    VkStructureType = 1000300001;
pub const VkStructureType_VK_STRUCTURE_TYPE_CUDA_MODULE_CREATE_INFO_NV: VkStructureType =
    1000307000;
pub const VkStructureType_VK_STRUCTURE_TYPE_CUDA_FUNCTION_CREATE_INFO_NV: VkStructureType =
    1000307001;
pub const VkStructureType_VK_STRUCTURE_TYPE_CUDA_LAUNCH_INFO_NV: VkStructureType = 1000307002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_FEATURES_NV:
    VkStructureType = 1000307003;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_PROPERTIES_NV:
    VkStructureType = 1000307004;
pub const VkStructureType_VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV: VkStructureType =
    1000310000;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT: VkStructureType =
    1000311000;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECTS_INFO_EXT: VkStructureType =
    1000311001;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXPORT_METAL_DEVICE_INFO_EXT: VkStructureType =
    1000311002;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXPORT_METAL_COMMAND_QUEUE_INFO_EXT: VkStructureType =
    1000311003;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXPORT_METAL_BUFFER_INFO_EXT: VkStructureType =
    1000311004;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMPORT_METAL_BUFFER_INFO_EXT: VkStructureType =
    1000311005;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXPORT_METAL_TEXTURE_INFO_EXT: VkStructureType =
    1000311006;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT: VkStructureType =
    1000311007;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXPORT_METAL_IO_SURFACE_INFO_EXT: VkStructureType =
    1000311008;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT: VkStructureType =
    1000311009;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXPORT_METAL_SHARED_EVENT_INFO_EXT: VkStructureType =
    1000311010;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMPORT_METAL_SHARED_EVENT_INFO_EXT: VkStructureType =
    1000311011;
pub const VkStructureType_VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV:
    VkStructureType = 1000314008;
pub const VkStructureType_VK_STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV: VkStructureType = 1000314009;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT:
    VkStructureType = 1000316000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT : VkStructureType = 1000316001 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT:
    VkStructureType = 1000316002;
pub const VkStructureType_VK_STRUCTURE_TYPE_DESCRIPTOR_ADDRESS_INFO_EXT: VkStructureType =
    1000316003;
pub const VkStructureType_VK_STRUCTURE_TYPE_DESCRIPTOR_GET_INFO_EXT: VkStructureType = 1000316004;
pub const VkStructureType_VK_STRUCTURE_TYPE_BUFFER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT:
    VkStructureType = 1000316005;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT:
    VkStructureType = 1000316006;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_EXT:
    VkStructureType = 1000316007;
pub const VkStructureType_VK_STRUCTURE_TYPE_SAMPLER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT:
    VkStructureType = 1000316008;
pub const VkStructureType_VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT:
    VkStructureType = 1000316010;
pub const VkStructureType_VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_INFO_EXT: VkStructureType =
    1000316011;
pub const VkStructureType_VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT : VkStructureType = 1000316012 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT : VkStructureType = 1000316009 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT : VkStructureType = 1000320000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT : VkStructureType = 1000320001 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT:
    VkStructureType = 1000320002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD : VkStructureType = 1000321000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR : VkStructureType = 1000203000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR : VkStructureType = 1000322000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR : VkStructureType = 1000323000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV : VkStructureType = 1000326000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV : VkStructureType = 1000326001 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV : VkStructureType = 1000326002 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV : VkStructureType = 1000327000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV:
    VkStructureType = 1000327001;
pub const VkStructureType_VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV: VkStructureType =
    1000327002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT:
    VkStructureType = 1000328000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT:
    VkStructureType = 1000328001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT : VkStructureType = 1000330000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT:
    VkStructureType = 1000332000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT : VkStructureType = 1000332001 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM: VkStructureType =
    1000333000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR : VkStructureType = 1000336000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT : VkStructureType = 1000338000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT: VkStructureType =
    1000338001;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT: VkStructureType =
    1000338004;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT : VkStructureType = 1000339000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT:
    VkStructureType = 1000340000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT: VkStructureType =
    1000341000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_FAULT_COUNTS_EXT: VkStructureType = 1000341001;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_FAULT_INFO_EXT: VkStructureType = 1000341002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT:
    VkStructureType = 1000344000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DIRECTFB_SURFACE_CREATE_INFO_EXT: VkStructureType =
    1000346000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT : VkStructureType = 1000352000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT:
    VkStructureType = 1000352001;
pub const VkStructureType_VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT:
    VkStructureType = 1000352002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT: VkStructureType =
    1000353000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT:
    VkStructureType = 1000354000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT:
    VkStructureType = 1000354001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT:
    VkStructureType = 1000355000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT:
    VkStructureType = 1000355001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT : VkStructureType = 1000356000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA:
    VkStructureType = 1000364000;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA:
    VkStructureType = 1000364001;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA: VkStructureType =
    1000364002;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA:
    VkStructureType = 1000365000;
pub const VkStructureType_VK_STRUCTURE_TYPE_SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA:
    VkStructureType = 1000365001;
pub const VkStructureType_VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CREATE_INFO_FUCHSIA: VkStructureType =
    1000366000;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA:
    VkStructureType = 1000366001;
pub const VkStructureType_VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA:
    VkStructureType = 1000366002;
pub const VkStructureType_VK_STRUCTURE_TYPE_BUFFER_COLLECTION_PROPERTIES_FUCHSIA: VkStructureType =
    1000366003;
pub const VkStructureType_VK_STRUCTURE_TYPE_BUFFER_CONSTRAINTS_INFO_FUCHSIA: VkStructureType =
    1000366004;
pub const VkStructureType_VK_STRUCTURE_TYPE_BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA:
    VkStructureType = 1000366005;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_CONSTRAINTS_INFO_FUCHSIA: VkStructureType =
    1000366006;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_FORMAT_CONSTRAINTS_INFO_FUCHSIA: VkStructureType =
    1000366007;
pub const VkStructureType_VK_STRUCTURE_TYPE_SYSMEM_COLOR_SPACE_FUCHSIA: VkStructureType =
    1000366008;
pub const VkStructureType_VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CONSTRAINTS_INFO_FUCHSIA:
    VkStructureType = 1000366009;
pub const VkStructureType_VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI:
    VkStructureType = 1000369000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI:
    VkStructureType = 1000369001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI:
    VkStructureType = 1000369002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI:
    VkStructureType = 1000370000;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_GET_REMOTE_ADDRESS_INFO_NV: VkStructureType =
    1000371000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV:
    VkStructureType = 1000371001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_PROPERTIES_IDENTIFIER_EXT: VkStructureType =
    1000372000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT:
    VkStructureType = 1000372001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT:
    VkStructureType = 1000375000;
pub const VkStructureType_VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT: VkStructureType = 1000375001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT : VkStructureType = 1000376000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT: VkStructureType =
    1000376001;
pub const VkStructureType_VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT:
    VkStructureType = 1000376002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT : VkStructureType = 1000377000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_SCREEN_SURFACE_CREATE_INFO_QNX: VkStructureType =
    1000378000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT:
    VkStructureType = 1000381000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT: VkStructureType =
    1000381001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT : VkStructureType = 1000382000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR : VkStructureType = 1000386000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT:
    VkStructureType = 1000391000;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT: VkStructureType =
    1000391001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT:
    VkStructureType = 1000392000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT:
    VkStructureType = 1000392001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT:
    VkStructureType = 1000393000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT:
    VkStructureType = 1000395000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT:
    VkStructureType = 1000395001;
pub const VkStructureType_VK_STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT: VkStructureType = 1000396000;
pub const VkStructureType_VK_STRUCTURE_TYPE_MICROMAP_VERSION_INFO_EXT: VkStructureType = 1000396001;
pub const VkStructureType_VK_STRUCTURE_TYPE_COPY_MICROMAP_INFO_EXT: VkStructureType = 1000396002;
pub const VkStructureType_VK_STRUCTURE_TYPE_COPY_MICROMAP_TO_MEMORY_INFO_EXT: VkStructureType =
    1000396003;
pub const VkStructureType_VK_STRUCTURE_TYPE_COPY_MEMORY_TO_MICROMAP_INFO_EXT: VkStructureType =
    1000396004;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT:
    VkStructureType = 1000396005;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT:
    VkStructureType = 1000396006;
pub const VkStructureType_VK_STRUCTURE_TYPE_MICROMAP_CREATE_INFO_EXT: VkStructureType = 1000396007;
pub const VkStructureType_VK_STRUCTURE_TYPE_MICROMAP_BUILD_SIZES_INFO_EXT: VkStructureType =
    1000396008;
pub const VkStructureType_VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT : VkStructureType = 1000396009 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI : VkStructureType = 1000404000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI : VkStructureType = 1000404001 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_VRS_FEATURES_HUAWEI : VkStructureType = 1000404002 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT:
    VkStructureType = 1000411000;
pub const VkStructureType_VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT : VkStructureType = 1000411001 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT : VkStructureType = 1000412000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM:
    VkStructureType = 1000415000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES_KHR:
    VkStructureType = 1000416000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_QUEUE_SHADER_CORE_CONTROL_CREATE_INFO_ARM:
    VkStructureType = 1000417000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_FEATURES_ARM:
    VkStructureType = 1000417001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_PROPERTIES_ARM:
    VkStructureType = 1000417002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT:
    VkStructureType = 1000418000;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_VIEW_SLICED_CREATE_INFO_EXT: VkStructureType =
    1000418001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE : VkStructureType = 1000420000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_DESCRIPTOR_SET_BINDING_REFERENCE_VALVE:
    VkStructureType = 1000420001;
pub const VkStructureType_VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE:
    VkStructureType = 1000420002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_EXT:
    VkStructureType = 1000421000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT:
    VkStructureType = 1000422000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_FEATURES_ARM:
    VkStructureType = 1000424000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_PROPERTIES_ARM:
    VkStructureType = 1000424001;
pub const VkStructureType_VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_BEGIN_INFO_ARM: VkStructureType =
    1000424002;
pub const VkStructureType_VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_INFO_ARM: VkStructureType =
    1000424003;
pub const VkStructureType_VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_SUBMIT_INFO_ARM: VkStructureType =
    1000424004;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM : VkStructureType = 1000425000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_QCOM : VkStructureType = 1000425001 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM:
    VkStructureType = 1000425002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV:
    VkStructureType = 1000426000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_NV:
    VkStructureType = 1000426001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV:
    VkStructureType = 1000427000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_NV:
    VkStructureType = 1000427001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV : VkStructureType = 1000428000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_INDIRECT_BUFFER_INFO_NV:
    VkStructureType = 1000428001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_INDIRECT_DEVICE_ADDRESS_INFO_NV:
    VkStructureType = 1000428002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV:
    VkStructureType = 1000430000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MAXIMAL_RECONVERGENCE_FEATURES_KHR : VkStructureType = 1000434000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT : VkStructureType = 1000437000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM:
    VkStructureType = 1000440000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM:
    VkStructureType = 1000440001;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM:
    VkStructureType = 1000440002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT:
    VkStructureType = 1000451000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_PROPERTIES_EXT:
    VkStructureType = 1000451001;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT:
    VkStructureType = 1000453000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT : VkStructureType = 1000455000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT : VkStructureType = 1000455001 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT:
    VkStructureType = 1000458000;
pub const VkStructureType_VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT: VkStructureType =
    1000458001;
pub const VkStructureType_VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT:
    VkStructureType = 1000458002;
pub const VkStructureType_VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT:
    VkStructureType = 1000458003;
pub const VkStructureType_VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_INFO_LUNARG: VkStructureType =
    1000459000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_LIST_LUNARG: VkStructureType =
    1000459001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT : VkStructureType = 1000462000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT : VkStructureType = 1000462001 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT : VkStructureType = 1000462002 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_SHADER_MODULE_IDENTIFIER_EXT: VkStructureType =
    1000462003;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT : VkStructureType = 1000342000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV:
    VkStructureType = 1000464000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV:
    VkStructureType = 1000464001;
pub const VkStructureType_VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV: VkStructureType =
    1000464002;
pub const VkStructureType_VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_PROPERTIES_NV:
    VkStructureType = 1000464003;
pub const VkStructureType_VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_INFO_NV: VkStructureType =
    1000464004;
pub const VkStructureType_VK_STRUCTURE_TYPE_OPTICAL_FLOW_EXECUTE_INFO_NV: VkStructureType =
    1000464005;
pub const VkStructureType_VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV:
    VkStructureType = 1000464010;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT:
    VkStructureType = 1000465000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES_EXT : VkStructureType = 1000466000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_FEATURES_ANDROID : VkStructureType = 1000468000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_PROPERTIES_ANDROID : VkStructureType = 1000468001 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_RESOLVE_PROPERTIES_ANDROID : VkStructureType = 1000468002 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES_KHR:
    VkStructureType = 1000470000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES_KHR:
    VkStructureType = 1000470001;
pub const VkStructureType_VK_STRUCTURE_TYPE_RENDERING_AREA_INFO_KHR: VkStructureType = 1000470003;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO_KHR: VkStructureType =
    1000470004;
pub const VkStructureType_VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_KHR: VkStructureType = 1000338002;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_KHR: VkStructureType = 1000338003;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO_KHR:
    VkStructureType = 1000470005;
pub const VkStructureType_VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO_KHR: VkStructureType =
    1000470006;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR : VkStructureType = 1000481000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT:
    VkStructureType = 1000482000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT:
    VkStructureType = 1000482001;
pub const VkStructureType_VK_STRUCTURE_TYPE_SHADER_CREATE_INFO_EXT: VkStructureType = 1000482002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM:
    VkStructureType = 1000484000;
pub const VkStructureType_VK_STRUCTURE_TYPE_TILE_PROPERTIES_QCOM: VkStructureType = 1000484001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC:
    VkStructureType = 1000485000;
pub const VkStructureType_VK_STRUCTURE_TYPE_AMIGO_PROFILING_SUBMIT_INFO_SEC: VkStructureType =
    1000485001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM : VkStructureType = 1000488000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV : VkStructureType = 1000490000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV : VkStructureType = 1000490001 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_FEATURES_NV : VkStructureType = 1000492000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_PROPERTIES_NV : VkStructureType = 1000492001 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT:
    VkStructureType = 1000351000;
pub const VkStructureType_VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT:
    VkStructureType = 1000351002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_FEATURES_EXT : VkStructureType = 1000495000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_PROPERTIES_EXT : VkStructureType = 1000495001 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT: VkStructureType =
    1000496000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM:
    VkStructureType = 1000497000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM:
    VkStructureType = 1000497001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT : VkStructureType = 1000498000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT : VkStructureType = 1000499000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_LATENCY_SLEEP_MODE_INFO_NV: VkStructureType =
    1000505000;
pub const VkStructureType_VK_STRUCTURE_TYPE_LATENCY_SLEEP_INFO_NV: VkStructureType = 1000505001;
pub const VkStructureType_VK_STRUCTURE_TYPE_SET_LATENCY_MARKER_INFO_NV: VkStructureType =
    1000505002;
pub const VkStructureType_VK_STRUCTURE_TYPE_GET_LATENCY_MARKER_INFO_NV: VkStructureType =
    1000505003;
pub const VkStructureType_VK_STRUCTURE_TYPE_LATENCY_TIMINGS_FRAME_REPORT_NV: VkStructureType =
    1000505004;
pub const VkStructureType_VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV: VkStructureType =
    1000505005;
pub const VkStructureType_VK_STRUCTURE_TYPE_OUT_OF_BAND_QUEUE_TYPE_INFO_NV: VkStructureType =
    1000505006;
pub const VkStructureType_VK_STRUCTURE_TYPE_SWAPCHAIN_LATENCY_CREATE_INFO_NV: VkStructureType =
    1000505007;
pub const VkStructureType_VK_STRUCTURE_TYPE_LATENCY_SURFACE_CAPABILITIES_NV: VkStructureType =
    1000505008;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR:
    VkStructureType = 1000506000;
pub const VkStructureType_VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_KHR: VkStructureType =
    1000506001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR:
    VkStructureType = 1000506002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM : VkStructureType = 1000510000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM : VkStructureType = 1000510001 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_CAPABILITIES_KHR: VkStructureType =
    1000512000;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PICTURE_INFO_KHR: VkStructureType =
    1000512001;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PROFILE_INFO_KHR: VkStructureType =
    1000512003;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR:
    VkStructureType = 1000512004;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_DPB_SLOT_INFO_KHR: VkStructureType =
    1000512005;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_1_FEATURES_KHR:
    VkStructureType = 1000515000;
pub const VkStructureType_VK_STRUCTURE_TYPE_VIDEO_INLINE_QUERY_INFO_KHR: VkStructureType =
    1000515001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PER_STAGE_DESCRIPTOR_SET_FEATURES_NV:
    VkStructureType = 1000516000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM:
    VkStructureType = 1000518000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_PROPERTIES_QCOM:
    VkStructureType = 1000518001;
pub const VkStructureType_VK_STRUCTURE_TYPE_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM:
    VkStructureType = 1000518002;
pub const VkStructureType_VK_STRUCTURE_TYPE_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM:
    VkStructureType = 1000519000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM:
    VkStructureType = 1000519001;
pub const VkStructureType_VK_STRUCTURE_TYPE_BLIT_IMAGE_CUBIC_WEIGHTS_INFO_QCOM: VkStructureType =
    1000519002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM:
    VkStructureType = 1000520000;
pub const VkStructureType_VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_YCBCR_DEGAMMA_CREATE_INFO_QCOM : VkStructureType = 1000520001 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM:
    VkStructureType = 1000521000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT : VkStructureType = 1000524000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_KHR : VkStructureType = 1000525000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_KHR:
    VkStructureType = 1000190001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_KHR : VkStructureType = 1000190002 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES_KHR:
    VkStructureType = 1000528000;
pub const VkStructureType_VK_STRUCTURE_TYPE_SCREEN_BUFFER_PROPERTIES_QNX: VkStructureType =
    1000529000;
pub const VkStructureType_VK_STRUCTURE_TYPE_SCREEN_BUFFER_FORMAT_PROPERTIES_QNX: VkStructureType =
    1000529001;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMPORT_SCREEN_BUFFER_INFO_QNX: VkStructureType =
    1000529002;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX: VkStructureType = 1000529003;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCREEN_BUFFER_FEATURES_QNX : VkStructureType = 1000529004 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT:
    VkStructureType = 1000530000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_KHR:
    VkStructureType = 1000265000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_KHR:
    VkStructureType = 1000259000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_KHR:
    VkStructureType = 1000259001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_KHR:
    VkStructureType = 1000259002;
pub const VkStructureType_VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_KHR: VkStructureType =
    1000184000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES_KHR:
    VkStructureType = 1000544000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES_KHR:
    VkStructureType = 1000545000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES_KHR:
    VkStructureType = 1000545001;
pub const VkStructureType_VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS_KHR: VkStructureType = 1000545002;
pub const VkStructureType_VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_SETS_INFO_KHR: VkStructureType =
    1000545003;
pub const VkStructureType_VK_STRUCTURE_TYPE_PUSH_CONSTANTS_INFO_KHR: VkStructureType = 1000545004;
pub const VkStructureType_VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_INFO_KHR: VkStructureType =
    1000545005;
pub const VkStructureType_VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_WITH_TEMPLATE_INFO_KHR:
    VkStructureType = 1000545006;
pub const VkStructureType_VK_STRUCTURE_TYPE_SET_DESCRIPTOR_BUFFER_OFFSETS_INFO_EXT:
    VkStructureType = 1000545007;
pub const VkStructureType_VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_BUFFER_EMBEDDED_SAMPLERS_INFO_EXT:
    VkStructureType = 1000545008;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV : VkStructureType = 1000546000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAW_ACCESS_CHAINS_FEATURES_NV:
    VkStructureType = 1000555000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT16_VECTOR_FEATURES_NV : VkStructureType = 1000563000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_VALIDATION_FEATURES_NV:
    VkStructureType = 1000568000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_FEATURES_MESA : VkStructureType = 1000575000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_PROPERTIES_MESA : VkStructureType = 1000575001 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_ALIGNMENT_CONTROL_CREATE_INFO_MESA:
    VkStructureType = 1000575002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES:
    VkStructureType = 1000120000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES:
    VkStructureType = 1000063000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT: VkStructureType =
    1000011000;
pub const VkStructureType_VK_STRUCTURE_TYPE_RENDERING_INFO_KHR: VkStructureType = 1000044000;
pub const VkStructureType_VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO_KHR: VkStructureType =
    1000044001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO_KHR: VkStructureType =
    1000044002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES_KHR:
    VkStructureType = 1000044003;
pub const VkStructureType_VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO_KHR:
    VkStructureType = 1000044004;
pub const VkStructureType_VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_NV: VkStructureType =
    1000044008;
pub const VkStructureType_VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR: VkStructureType =
    1000053000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR:
    VkStructureType = 1000053001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR:
    VkStructureType = 1000053002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR: VkStructureType =
    1000059000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR: VkStructureType =
    1000059001;
pub const VkStructureType_VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR: VkStructureType = 1000059002;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR: VkStructureType =
    1000059003;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR:
    VkStructureType = 1000059004;
pub const VkStructureType_VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR: VkStructureType =
    1000059005;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR:
    VkStructureType = 1000059006;
pub const VkStructureType_VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR: VkStructureType =
    1000059007;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR:
    VkStructureType = 1000059008;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHR: VkStructureType =
    1000060000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHR:
    VkStructureType = 1000060003;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHR:
    VkStructureType = 1000060004;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHR: VkStructureType =
    1000060005;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHR: VkStructureType =
    1000060006;
pub const VkStructureType_VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR:
    VkStructureType = 1000060013;
pub const VkStructureType_VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR:
    VkStructureType = 1000060014;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT : VkStructureType = 1000066000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR: VkStructureType =
    1000070000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHR: VkStructureType =
    1000070001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR:
    VkStructureType = 1000071000;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR: VkStructureType =
    1000071001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR:
    VkStructureType = 1000071002;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHR: VkStructureType =
    1000071003;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR: VkStructureType =
    1000071004;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR:
    VkStructureType = 1000072000;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR: VkStructureType =
    1000072001;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR: VkStructureType =
    1000072002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR:
    VkStructureType = 1000076000;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR: VkStructureType =
    1000076001;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR: VkStructureType =
    1000077000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES_KHR:
    VkStructureType = 1000082000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT16_INT8_FEATURES_KHR:
    VkStructureType = 1000082000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR:
    VkStructureType = 1000083000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR:
    VkStructureType = 1000085000;
pub const VkStructureType_VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES2_EXT: VkStructureType = 1000090000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES_KHR:
    VkStructureType = 1000108000;
pub const VkStructureType_VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO_KHR:
    VkStructureType = 1000108001;
pub const VkStructureType_VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO_KHR: VkStructureType =
    1000108002;
pub const VkStructureType_VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO_KHR: VkStructureType =
    1000108003;
pub const VkStructureType_VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR: VkStructureType =
    1000109000;
pub const VkStructureType_VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR: VkStructureType =
    1000109001;
pub const VkStructureType_VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR: VkStructureType = 1000109002;
pub const VkStructureType_VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR: VkStructureType = 1000109003;
pub const VkStructureType_VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR: VkStructureType =
    1000109004;
pub const VkStructureType_VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR: VkStructureType = 1000109005;
pub const VkStructureType_VK_STRUCTURE_TYPE_SUBPASS_END_INFO_KHR: VkStructureType = 1000109006;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR:
    VkStructureType = 1000112000;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES_KHR: VkStructureType =
    1000112001;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO_KHR: VkStructureType =
    1000113000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR:
    VkStructureType = 1000117000;
pub const VkStructureType_VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR:
    VkStructureType = 1000117001;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO_KHR: VkStructureType =
    1000117002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR : VkStructureType = 1000117003 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR:
    VkStructureType = 1000120000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR:
    VkStructureType = 1000120000;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR: VkStructureType =
    1000127000;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR: VkStructureType =
    1000127001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT:
    VkStructureType = 1000130000;
pub const VkStructureType_VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT:
    VkStructureType = 1000130001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT:
    VkStructureType = 1000138000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT:
    VkStructureType = 1000138001;
pub const VkStructureType_VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT:
    VkStructureType = 1000138002;
pub const VkStructureType_VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT:
    VkStructureType = 1000138003;
pub const VkStructureType_VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR: VkStructureType =
    1000146000;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR: VkStructureType =
    1000146001;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR:
    VkStructureType = 1000146002;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR: VkStructureType = 1000146003;
pub const VkStructureType_VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR:
    VkStructureType = 1000146004;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR: VkStructureType =
    1000147000;
pub const VkStructureType_VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR:
    VkStructureType = 1000156000;
pub const VkStructureType_VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO_KHR: VkStructureType =
    1000156001;
pub const VkStructureType_VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO_KHR: VkStructureType =
    1000156002;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR:
    VkStructureType = 1000156003;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR : VkStructureType = 1000156004 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR:
    VkStructureType = 1000156005;
pub const VkStructureType_VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHR: VkStructureType =
    1000157000;
pub const VkStructureType_VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHR: VkStructureType =
    1000157001;
pub const VkStructureType_VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT:
    VkStructureType = 1000161000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT:
    VkStructureType = 1000161001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT:
    VkStructureType = 1000161002;
pub const VkStructureType_VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT : VkStructureType = 1000161003 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT : VkStructureType = 1000161004 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES_KHR:
    VkStructureType = 1000168000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR: VkStructureType =
    1000168001;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT:
    VkStructureType = 1000174000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES_KHR : VkStructureType = 1000175000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR:
    VkStructureType = 1000177000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR:
    VkStructureType = 1000180000;
pub const VkStructureType_VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT: VkStructureType =
    1000184000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT:
    VkStructureType = 1000190001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT : VkStructureType = 1000190002 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT:
    VkStructureType = 1000192000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR: VkStructureType =
    1000196000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR:
    VkStructureType = 1000197000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR:
    VkStructureType = 1000199000;
pub const VkStructureType_VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR:
    VkStructureType = 1000199001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV : VkStructureType = 1000203000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES_KHR:
    VkStructureType = 1000207000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES_KHR:
    VkStructureType = 1000207001;
pub const VkStructureType_VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO_KHR: VkStructureType =
    1000207002;
pub const VkStructureType_VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO_KHR: VkStructureType =
    1000207003;
pub const VkStructureType_VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO_KHR: VkStructureType = 1000207004;
pub const VkStructureType_VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO_KHR: VkStructureType = 1000207005;
pub const VkStructureType_VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO_INTEL: VkStructureType =
    1000210000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR:
    VkStructureType = 1000211000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES_KHR : VkStructureType = 1000215000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT:
    VkStructureType = 1000221000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT:
    VkStructureType = 1000225000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT : VkStructureType = 1000225001 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT:
    VkStructureType = 1000225002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES_KHR : VkStructureType = 1000241000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT_KHR:
    VkStructureType = 1000241001;
pub const VkStructureType_VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT_KHR:
    VkStructureType = 1000241002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_ADDRESS_FEATURES_EXT:
    VkStructureType = 1000244000;
pub const VkStructureType_VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_EXT: VkStructureType =
    1000244001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES_EXT: VkStructureType =
    1000245000;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO_EXT: VkStructureType =
    1000246000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES_KHR : VkStructureType = 1000253000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_KHR:
    VkStructureType = 1000257000;
pub const VkStructureType_VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_KHR: VkStructureType =
    1000244001;
pub const VkStructureType_VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO_KHR:
    VkStructureType = 1000257002;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO_KHR:
    VkStructureType = 1000257003;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO_KHR:
    VkStructureType = 1000257004;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT:
    VkStructureType = 1000259000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT:
    VkStructureType = 1000259001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT:
    VkStructureType = 1000259002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT:
    VkStructureType = 1000261000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT:
    VkStructureType = 1000265000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT : VkStructureType = 1000276000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES_KHR : VkStructureType = 1000280000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES_KHR : VkStructureType = 1000280001 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT : VkStructureType = 1000281001 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES_EXT:
    VkStructureType = 1000295000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO_EXT: VkStructureType =
    1000295001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO_EXT: VkStructureType =
    1000295002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES_EXT : VkStructureType = 1000297000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_BARRIER_2_KHR: VkStructureType = 1000314000;
pub const VkStructureType_VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2_KHR: VkStructureType =
    1000314001;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2_KHR: VkStructureType =
    1000314002;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEPENDENCY_INFO_KHR: VkStructureType = 1000314003;
pub const VkStructureType_VK_STRUCTURE_TYPE_SUBMIT_INFO_2_KHR: VkStructureType = 1000314004;
pub const VkStructureType_VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO_KHR: VkStructureType = 1000314005;
pub const VkStructureType_VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO_KHR: VkStructureType =
    1000314006;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES_KHR:
    VkStructureType = 1000314007;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES_KHR : VkStructureType = 1000325000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES_EXT:
    VkStructureType = 1000335000;
pub const VkStructureType_VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2_KHR: VkStructureType = 1000337000;
pub const VkStructureType_VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2_KHR: VkStructureType = 1000337001;
pub const VkStructureType_VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2_KHR: VkStructureType =
    1000337002;
pub const VkStructureType_VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2_KHR: VkStructureType =
    1000337003;
pub const VkStructureType_VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2_KHR: VkStructureType = 1000337004;
pub const VkStructureType_VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2_KHR: VkStructureType = 1000337005;
pub const VkStructureType_VK_STRUCTURE_TYPE_BUFFER_COPY_2_KHR: VkStructureType = 1000337006;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_COPY_2_KHR: VkStructureType = 1000337007;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_BLIT_2_KHR: VkStructureType = 1000337008;
pub const VkStructureType_VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2_KHR: VkStructureType = 1000337009;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2_KHR: VkStructureType = 1000337010;
pub const VkStructureType_VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_EXT: VkStructureType = 1000338002;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_EXT: VkStructureType = 1000338003;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_ARM : VkStructureType = 1000342000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_VALVE : VkStructureType = 1000351000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_VALVE:
    VkStructureType = 1000351002;
pub const VkStructureType_VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3_KHR: VkStructureType = 1000360000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_INFO_EXT: VkStructureType = 1000269001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_EXT:
    VkStructureType = 1000388000;
pub const VkStructureType_VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_EXT:
    VkStructureType = 1000388001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES_KHR:
    VkStructureType = 1000413000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES_KHR:
    VkStructureType = 1000413001;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS_KHR: VkStructureType =
    1000413002;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS_KHR: VkStructureType =
    1000413003;
pub const VkStructureType_VK_STRUCTURE_TYPE_SHADER_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT:
    VkStructureType = 1000225001;
pub const VkStructureType_VK_STRUCTURE_TYPE_MAX_ENUM: VkStructureType = 2147483647;
pub type VkStructureType = ::std::os::raw::c_uint;
pub const VkImageLayout_VK_IMAGE_LAYOUT_UNDEFINED: VkImageLayout = 0;
pub const VkImageLayout_VK_IMAGE_LAYOUT_GENERAL: VkImageLayout = 1;
pub const VkImageLayout_VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL: VkImageLayout = 2;
pub const VkImageLayout_VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL: VkImageLayout = 3;
pub const VkImageLayout_VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL: VkImageLayout = 4;
pub const VkImageLayout_VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL: VkImageLayout = 5;
pub const VkImageLayout_VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL: VkImageLayout = 6;
pub const VkImageLayout_VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL: VkImageLayout = 7;
pub const VkImageLayout_VK_IMAGE_LAYOUT_PREINITIALIZED: VkImageLayout = 8;
pub const VkImageLayout_VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL: VkImageLayout =
    1000117000;
pub const VkImageLayout_VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL: VkImageLayout =
    1000117001;
pub const VkImageLayout_VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL: VkImageLayout = 1000241000;
pub const VkImageLayout_VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL: VkImageLayout = 1000241001;
pub const VkImageLayout_VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL: VkImageLayout = 1000241002;
pub const VkImageLayout_VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL: VkImageLayout = 1000241003;
pub const VkImageLayout_VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL: VkImageLayout = 1000314000;
pub const VkImageLayout_VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL: VkImageLayout = 1000314001;
pub const VkImageLayout_VK_IMAGE_LAYOUT_PRESENT_SRC_KHR: VkImageLayout = 1000001002;
pub const VkImageLayout_VK_IMAGE_LAYOUT_VIDEO_DECODE_DST_KHR: VkImageLayout = 1000024000;
pub const VkImageLayout_VK_IMAGE_LAYOUT_VIDEO_DECODE_SRC_KHR: VkImageLayout = 1000024001;
pub const VkImageLayout_VK_IMAGE_LAYOUT_VIDEO_DECODE_DPB_KHR: VkImageLayout = 1000024002;
pub const VkImageLayout_VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR: VkImageLayout = 1000111000;
pub const VkImageLayout_VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT: VkImageLayout =
    1000218000;
pub const VkImageLayout_VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR:
    VkImageLayout = 1000164003;
pub const VkImageLayout_VK_IMAGE_LAYOUT_RENDERING_LOCAL_READ_KHR: VkImageLayout = 1000232000;
pub const VkImageLayout_VK_IMAGE_LAYOUT_VIDEO_ENCODE_DST_KHR: VkImageLayout = 1000299000;
pub const VkImageLayout_VK_IMAGE_LAYOUT_VIDEO_ENCODE_SRC_KHR: VkImageLayout = 1000299001;
pub const VkImageLayout_VK_IMAGE_LAYOUT_VIDEO_ENCODE_DPB_KHR: VkImageLayout = 1000299002;
pub const VkImageLayout_VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT: VkImageLayout =
    1000339000;
pub const VkImageLayout_VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR:
    VkImageLayout = 1000117000;
pub const VkImageLayout_VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR:
    VkImageLayout = 1000117001;
pub const VkImageLayout_VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV: VkImageLayout = 1000164003;
pub const VkImageLayout_VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL_KHR: VkImageLayout = 1000241000;
pub const VkImageLayout_VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL_KHR: VkImageLayout = 1000241001;
pub const VkImageLayout_VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL_KHR: VkImageLayout = 1000241002;
pub const VkImageLayout_VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL_KHR: VkImageLayout = 1000241003;
pub const VkImageLayout_VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR: VkImageLayout = 1000314000;
pub const VkImageLayout_VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL_KHR: VkImageLayout = 1000314001;
pub const VkImageLayout_VK_IMAGE_LAYOUT_MAX_ENUM: VkImageLayout = 2147483647;
pub type VkImageLayout = ::std::os::raw::c_uint;
pub const VkSystemAllocationScope_VK_SYSTEM_ALLOCATION_SCOPE_COMMAND: VkSystemAllocationScope = 0;
pub const VkSystemAllocationScope_VK_SYSTEM_ALLOCATION_SCOPE_OBJECT: VkSystemAllocationScope = 1;
pub const VkSystemAllocationScope_VK_SYSTEM_ALLOCATION_SCOPE_CACHE: VkSystemAllocationScope = 2;
pub const VkSystemAllocationScope_VK_SYSTEM_ALLOCATION_SCOPE_DEVICE: VkSystemAllocationScope = 3;
pub const VkSystemAllocationScope_VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE: VkSystemAllocationScope = 4;
pub const VkSystemAllocationScope_VK_SYSTEM_ALLOCATION_SCOPE_MAX_ENUM: VkSystemAllocationScope =
    2147483647;
pub type VkSystemAllocationScope = ::std::os::raw::c_uint;
pub const VkInternalAllocationType_VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE:
    VkInternalAllocationType = 0;
pub const VkInternalAllocationType_VK_INTERNAL_ALLOCATION_TYPE_MAX_ENUM: VkInternalAllocationType =
    2147483647;
pub type VkInternalAllocationType = ::std::os::raw::c_uint;
pub const VkFormat_VK_FORMAT_UNDEFINED: VkFormat = 0;
pub const VkFormat_VK_FORMAT_R4G4_UNORM_PACK8: VkFormat = 1;
pub const VkFormat_VK_FORMAT_R4G4B4A4_UNORM_PACK16: VkFormat = 2;
pub const VkFormat_VK_FORMAT_B4G4R4A4_UNORM_PACK16: VkFormat = 3;
pub const VkFormat_VK_FORMAT_R5G6B5_UNORM_PACK16: VkFormat = 4;
pub const VkFormat_VK_FORMAT_B5G6R5_UNORM_PACK16: VkFormat = 5;
pub const VkFormat_VK_FORMAT_R5G5B5A1_UNORM_PACK16: VkFormat = 6;
pub const VkFormat_VK_FORMAT_B5G5R5A1_UNORM_PACK16: VkFormat = 7;
pub const VkFormat_VK_FORMAT_A1R5G5B5_UNORM_PACK16: VkFormat = 8;
pub const VkFormat_VK_FORMAT_R8_UNORM: VkFormat = 9;
pub const VkFormat_VK_FORMAT_R8_SNORM: VkFormat = 10;
pub const VkFormat_VK_FORMAT_R8_USCALED: VkFormat = 11;
pub const VkFormat_VK_FORMAT_R8_SSCALED: VkFormat = 12;
pub const VkFormat_VK_FORMAT_R8_UINT: VkFormat = 13;
pub const VkFormat_VK_FORMAT_R8_SINT: VkFormat = 14;
pub const VkFormat_VK_FORMAT_R8_SRGB: VkFormat = 15;
pub const VkFormat_VK_FORMAT_R8G8_UNORM: VkFormat = 16;
pub const VkFormat_VK_FORMAT_R8G8_SNORM: VkFormat = 17;
pub const VkFormat_VK_FORMAT_R8G8_USCALED: VkFormat = 18;
pub const VkFormat_VK_FORMAT_R8G8_SSCALED: VkFormat = 19;
pub const VkFormat_VK_FORMAT_R8G8_UINT: VkFormat = 20;
pub const VkFormat_VK_FORMAT_R8G8_SINT: VkFormat = 21;
pub const VkFormat_VK_FORMAT_R8G8_SRGB: VkFormat = 22;
pub const VkFormat_VK_FORMAT_R8G8B8_UNORM: VkFormat = 23;
pub const VkFormat_VK_FORMAT_R8G8B8_SNORM: VkFormat = 24;
pub const VkFormat_VK_FORMAT_R8G8B8_USCALED: VkFormat = 25;
pub const VkFormat_VK_FORMAT_R8G8B8_SSCALED: VkFormat = 26;
pub const VkFormat_VK_FORMAT_R8G8B8_UINT: VkFormat = 27;
pub const VkFormat_VK_FORMAT_R8G8B8_SINT: VkFormat = 28;
pub const VkFormat_VK_FORMAT_R8G8B8_SRGB: VkFormat = 29;
pub const VkFormat_VK_FORMAT_B8G8R8_UNORM: VkFormat = 30;
pub const VkFormat_VK_FORMAT_B8G8R8_SNORM: VkFormat = 31;
pub const VkFormat_VK_FORMAT_B8G8R8_USCALED: VkFormat = 32;
pub const VkFormat_VK_FORMAT_B8G8R8_SSCALED: VkFormat = 33;
pub const VkFormat_VK_FORMAT_B8G8R8_UINT: VkFormat = 34;
pub const VkFormat_VK_FORMAT_B8G8R8_SINT: VkFormat = 35;
pub const VkFormat_VK_FORMAT_B8G8R8_SRGB: VkFormat = 36;
pub const VkFormat_VK_FORMAT_R8G8B8A8_UNORM: VkFormat = 37;
pub const VkFormat_VK_FORMAT_R8G8B8A8_SNORM: VkFormat = 38;
pub const VkFormat_VK_FORMAT_R8G8B8A8_USCALED: VkFormat = 39;
pub const VkFormat_VK_FORMAT_R8G8B8A8_SSCALED: VkFormat = 40;
pub const VkFormat_VK_FORMAT_R8G8B8A8_UINT: VkFormat = 41;
pub const VkFormat_VK_FORMAT_R8G8B8A8_SINT: VkFormat = 42;
pub const VkFormat_VK_FORMAT_R8G8B8A8_SRGB: VkFormat = 43;
pub const VkFormat_VK_FORMAT_B8G8R8A8_UNORM: VkFormat = 44;
pub const VkFormat_VK_FORMAT_B8G8R8A8_SNORM: VkFormat = 45;
pub const VkFormat_VK_FORMAT_B8G8R8A8_USCALED: VkFormat = 46;
pub const VkFormat_VK_FORMAT_B8G8R8A8_SSCALED: VkFormat = 47;
pub const VkFormat_VK_FORMAT_B8G8R8A8_UINT: VkFormat = 48;
pub const VkFormat_VK_FORMAT_B8G8R8A8_SINT: VkFormat = 49;
pub const VkFormat_VK_FORMAT_B8G8R8A8_SRGB: VkFormat = 50;
pub const VkFormat_VK_FORMAT_A8B8G8R8_UNORM_PACK32: VkFormat = 51;
pub const VkFormat_VK_FORMAT_A8B8G8R8_SNORM_PACK32: VkFormat = 52;
pub const VkFormat_VK_FORMAT_A8B8G8R8_USCALED_PACK32: VkFormat = 53;
pub const VkFormat_VK_FORMAT_A8B8G8R8_SSCALED_PACK32: VkFormat = 54;
pub const VkFormat_VK_FORMAT_A8B8G8R8_UINT_PACK32: VkFormat = 55;
pub const VkFormat_VK_FORMAT_A8B8G8R8_SINT_PACK32: VkFormat = 56;
pub const VkFormat_VK_FORMAT_A8B8G8R8_SRGB_PACK32: VkFormat = 57;
pub const VkFormat_VK_FORMAT_A2R10G10B10_UNORM_PACK32: VkFormat = 58;
pub const VkFormat_VK_FORMAT_A2R10G10B10_SNORM_PACK32: VkFormat = 59;
pub const VkFormat_VK_FORMAT_A2R10G10B10_USCALED_PACK32: VkFormat = 60;
pub const VkFormat_VK_FORMAT_A2R10G10B10_SSCALED_PACK32: VkFormat = 61;
pub const VkFormat_VK_FORMAT_A2R10G10B10_UINT_PACK32: VkFormat = 62;
pub const VkFormat_VK_FORMAT_A2R10G10B10_SINT_PACK32: VkFormat = 63;
pub const VkFormat_VK_FORMAT_A2B10G10R10_UNORM_PACK32: VkFormat = 64;
pub const VkFormat_VK_FORMAT_A2B10G10R10_SNORM_PACK32: VkFormat = 65;
pub const VkFormat_VK_FORMAT_A2B10G10R10_USCALED_PACK32: VkFormat = 66;
pub const VkFormat_VK_FORMAT_A2B10G10R10_SSCALED_PACK32: VkFormat = 67;
pub const VkFormat_VK_FORMAT_A2B10G10R10_UINT_PACK32: VkFormat = 68;
pub const VkFormat_VK_FORMAT_A2B10G10R10_SINT_PACK32: VkFormat = 69;
pub const VkFormat_VK_FORMAT_R16_UNORM: VkFormat = 70;
pub const VkFormat_VK_FORMAT_R16_SNORM: VkFormat = 71;
pub const VkFormat_VK_FORMAT_R16_USCALED: VkFormat = 72;
pub const VkFormat_VK_FORMAT_R16_SSCALED: VkFormat = 73;
pub const VkFormat_VK_FORMAT_R16_UINT: VkFormat = 74;
pub const VkFormat_VK_FORMAT_R16_SINT: VkFormat = 75;
pub const VkFormat_VK_FORMAT_R16_SFLOAT: VkFormat = 76;
pub const VkFormat_VK_FORMAT_R16G16_UNORM: VkFormat = 77;
pub const VkFormat_VK_FORMAT_R16G16_SNORM: VkFormat = 78;
pub const VkFormat_VK_FORMAT_R16G16_USCALED: VkFormat = 79;
pub const VkFormat_VK_FORMAT_R16G16_SSCALED: VkFormat = 80;
pub const VkFormat_VK_FORMAT_R16G16_UINT: VkFormat = 81;
pub const VkFormat_VK_FORMAT_R16G16_SINT: VkFormat = 82;
pub const VkFormat_VK_FORMAT_R16G16_SFLOAT: VkFormat = 83;
pub const VkFormat_VK_FORMAT_R16G16B16_UNORM: VkFormat = 84;
pub const VkFormat_VK_FORMAT_R16G16B16_SNORM: VkFormat = 85;
pub const VkFormat_VK_FORMAT_R16G16B16_USCALED: VkFormat = 86;
pub const VkFormat_VK_FORMAT_R16G16B16_SSCALED: VkFormat = 87;
pub const VkFormat_VK_FORMAT_R16G16B16_UINT: VkFormat = 88;
pub const VkFormat_VK_FORMAT_R16G16B16_SINT: VkFormat = 89;
pub const VkFormat_VK_FORMAT_R16G16B16_SFLOAT: VkFormat = 90;
pub const VkFormat_VK_FORMAT_R16G16B16A16_UNORM: VkFormat = 91;
pub const VkFormat_VK_FORMAT_R16G16B16A16_SNORM: VkFormat = 92;
pub const VkFormat_VK_FORMAT_R16G16B16A16_USCALED: VkFormat = 93;
pub const VkFormat_VK_FORMAT_R16G16B16A16_SSCALED: VkFormat = 94;
pub const VkFormat_VK_FORMAT_R16G16B16A16_UINT: VkFormat = 95;
pub const VkFormat_VK_FORMAT_R16G16B16A16_SINT: VkFormat = 96;
pub const VkFormat_VK_FORMAT_R16G16B16A16_SFLOAT: VkFormat = 97;
pub const VkFormat_VK_FORMAT_R32_UINT: VkFormat = 98;
pub const VkFormat_VK_FORMAT_R32_SINT: VkFormat = 99;
pub const VkFormat_VK_FORMAT_R32_SFLOAT: VkFormat = 100;
pub const VkFormat_VK_FORMAT_R32G32_UINT: VkFormat = 101;
pub const VkFormat_VK_FORMAT_R32G32_SINT: VkFormat = 102;
pub const VkFormat_VK_FORMAT_R32G32_SFLOAT: VkFormat = 103;
pub const VkFormat_VK_FORMAT_R32G32B32_UINT: VkFormat = 104;
pub const VkFormat_VK_FORMAT_R32G32B32_SINT: VkFormat = 105;
pub const VkFormat_VK_FORMAT_R32G32B32_SFLOAT: VkFormat = 106;
pub const VkFormat_VK_FORMAT_R32G32B32A32_UINT: VkFormat = 107;
pub const VkFormat_VK_FORMAT_R32G32B32A32_SINT: VkFormat = 108;
pub const VkFormat_VK_FORMAT_R32G32B32A32_SFLOAT: VkFormat = 109;
pub const VkFormat_VK_FORMAT_R64_UINT: VkFormat = 110;
pub const VkFormat_VK_FORMAT_R64_SINT: VkFormat = 111;
pub const VkFormat_VK_FORMAT_R64_SFLOAT: VkFormat = 112;
pub const VkFormat_VK_FORMAT_R64G64_UINT: VkFormat = 113;
pub const VkFormat_VK_FORMAT_R64G64_SINT: VkFormat = 114;
pub const VkFormat_VK_FORMAT_R64G64_SFLOAT: VkFormat = 115;
pub const VkFormat_VK_FORMAT_R64G64B64_UINT: VkFormat = 116;
pub const VkFormat_VK_FORMAT_R64G64B64_SINT: VkFormat = 117;
pub const VkFormat_VK_FORMAT_R64G64B64_SFLOAT: VkFormat = 118;
pub const VkFormat_VK_FORMAT_R64G64B64A64_UINT: VkFormat = 119;
pub const VkFormat_VK_FORMAT_R64G64B64A64_SINT: VkFormat = 120;
pub const VkFormat_VK_FORMAT_R64G64B64A64_SFLOAT: VkFormat = 121;
pub const VkFormat_VK_FORMAT_B10G11R11_UFLOAT_PACK32: VkFormat = 122;
pub const VkFormat_VK_FORMAT_E5B9G9R9_UFLOAT_PACK32: VkFormat = 123;
pub const VkFormat_VK_FORMAT_D16_UNORM: VkFormat = 124;
pub const VkFormat_VK_FORMAT_X8_D24_UNORM_PACK32: VkFormat = 125;
pub const VkFormat_VK_FORMAT_D32_SFLOAT: VkFormat = 126;
pub const VkFormat_VK_FORMAT_S8_UINT: VkFormat = 127;
pub const VkFormat_VK_FORMAT_D16_UNORM_S8_UINT: VkFormat = 128;
pub const VkFormat_VK_FORMAT_D24_UNORM_S8_UINT: VkFormat = 129;
pub const VkFormat_VK_FORMAT_D32_SFLOAT_S8_UINT: VkFormat = 130;
pub const VkFormat_VK_FORMAT_BC1_RGB_UNORM_BLOCK: VkFormat = 131;
pub const VkFormat_VK_FORMAT_BC1_RGB_SRGB_BLOCK: VkFormat = 132;
pub const VkFormat_VK_FORMAT_BC1_RGBA_UNORM_BLOCK: VkFormat = 133;
pub const VkFormat_VK_FORMAT_BC1_RGBA_SRGB_BLOCK: VkFormat = 134;
pub const VkFormat_VK_FORMAT_BC2_UNORM_BLOCK: VkFormat = 135;
pub const VkFormat_VK_FORMAT_BC2_SRGB_BLOCK: VkFormat = 136;
pub const VkFormat_VK_FORMAT_BC3_UNORM_BLOCK: VkFormat = 137;
pub const VkFormat_VK_FORMAT_BC3_SRGB_BLOCK: VkFormat = 138;
pub const VkFormat_VK_FORMAT_BC4_UNORM_BLOCK: VkFormat = 139;
pub const VkFormat_VK_FORMAT_BC4_SNORM_BLOCK: VkFormat = 140;
pub const VkFormat_VK_FORMAT_BC5_UNORM_BLOCK: VkFormat = 141;
pub const VkFormat_VK_FORMAT_BC5_SNORM_BLOCK: VkFormat = 142;
pub const VkFormat_VK_FORMAT_BC6H_UFLOAT_BLOCK: VkFormat = 143;
pub const VkFormat_VK_FORMAT_BC6H_SFLOAT_BLOCK: VkFormat = 144;
pub const VkFormat_VK_FORMAT_BC7_UNORM_BLOCK: VkFormat = 145;
pub const VkFormat_VK_FORMAT_BC7_SRGB_BLOCK: VkFormat = 146;
pub const VkFormat_VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK: VkFormat = 147;
pub const VkFormat_VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK: VkFormat = 148;
pub const VkFormat_VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK: VkFormat = 149;
pub const VkFormat_VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK: VkFormat = 150;
pub const VkFormat_VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK: VkFormat = 151;
pub const VkFormat_VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK: VkFormat = 152;
pub const VkFormat_VK_FORMAT_EAC_R11_UNORM_BLOCK: VkFormat = 153;
pub const VkFormat_VK_FORMAT_EAC_R11_SNORM_BLOCK: VkFormat = 154;
pub const VkFormat_VK_FORMAT_EAC_R11G11_UNORM_BLOCK: VkFormat = 155;
pub const VkFormat_VK_FORMAT_EAC_R11G11_SNORM_BLOCK: VkFormat = 156;
pub const VkFormat_VK_FORMAT_ASTC_4x4_UNORM_BLOCK: VkFormat = 157;
pub const VkFormat_VK_FORMAT_ASTC_4x4_SRGB_BLOCK: VkFormat = 158;
pub const VkFormat_VK_FORMAT_ASTC_5x4_UNORM_BLOCK: VkFormat = 159;
pub const VkFormat_VK_FORMAT_ASTC_5x4_SRGB_BLOCK: VkFormat = 160;
pub const VkFormat_VK_FORMAT_ASTC_5x5_UNORM_BLOCK: VkFormat = 161;
pub const VkFormat_VK_FORMAT_ASTC_5x5_SRGB_BLOCK: VkFormat = 162;
pub const VkFormat_VK_FORMAT_ASTC_6x5_UNORM_BLOCK: VkFormat = 163;
pub const VkFormat_VK_FORMAT_ASTC_6x5_SRGB_BLOCK: VkFormat = 164;
pub const VkFormat_VK_FORMAT_ASTC_6x6_UNORM_BLOCK: VkFormat = 165;
pub const VkFormat_VK_FORMAT_ASTC_6x6_SRGB_BLOCK: VkFormat = 166;
pub const VkFormat_VK_FORMAT_ASTC_8x5_UNORM_BLOCK: VkFormat = 167;
pub const VkFormat_VK_FORMAT_ASTC_8x5_SRGB_BLOCK: VkFormat = 168;
pub const VkFormat_VK_FORMAT_ASTC_8x6_UNORM_BLOCK: VkFormat = 169;
pub const VkFormat_VK_FORMAT_ASTC_8x6_SRGB_BLOCK: VkFormat = 170;
pub const VkFormat_VK_FORMAT_ASTC_8x8_UNORM_BLOCK: VkFormat = 171;
pub const VkFormat_VK_FORMAT_ASTC_8x8_SRGB_BLOCK: VkFormat = 172;
pub const VkFormat_VK_FORMAT_ASTC_10x5_UNORM_BLOCK: VkFormat = 173;
pub const VkFormat_VK_FORMAT_ASTC_10x5_SRGB_BLOCK: VkFormat = 174;
pub const VkFormat_VK_FORMAT_ASTC_10x6_UNORM_BLOCK: VkFormat = 175;
pub const VkFormat_VK_FORMAT_ASTC_10x6_SRGB_BLOCK: VkFormat = 176;
pub const VkFormat_VK_FORMAT_ASTC_10x8_UNORM_BLOCK: VkFormat = 177;
pub const VkFormat_VK_FORMAT_ASTC_10x8_SRGB_BLOCK: VkFormat = 178;
pub const VkFormat_VK_FORMAT_ASTC_10x10_UNORM_BLOCK: VkFormat = 179;
pub const VkFormat_VK_FORMAT_ASTC_10x10_SRGB_BLOCK: VkFormat = 180;
pub const VkFormat_VK_FORMAT_ASTC_12x10_UNORM_BLOCK: VkFormat = 181;
pub const VkFormat_VK_FORMAT_ASTC_12x10_SRGB_BLOCK: VkFormat = 182;
pub const VkFormat_VK_FORMAT_ASTC_12x12_UNORM_BLOCK: VkFormat = 183;
pub const VkFormat_VK_FORMAT_ASTC_12x12_SRGB_BLOCK: VkFormat = 184;
pub const VkFormat_VK_FORMAT_G8B8G8R8_422_UNORM: VkFormat = 1000156000;
pub const VkFormat_VK_FORMAT_B8G8R8G8_422_UNORM: VkFormat = 1000156001;
pub const VkFormat_VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM: VkFormat = 1000156002;
pub const VkFormat_VK_FORMAT_G8_B8R8_2PLANE_420_UNORM: VkFormat = 1000156003;
pub const VkFormat_VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM: VkFormat = 1000156004;
pub const VkFormat_VK_FORMAT_G8_B8R8_2PLANE_422_UNORM: VkFormat = 1000156005;
pub const VkFormat_VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM: VkFormat = 1000156006;
pub const VkFormat_VK_FORMAT_R10X6_UNORM_PACK16: VkFormat = 1000156007;
pub const VkFormat_VK_FORMAT_R10X6G10X6_UNORM_2PACK16: VkFormat = 1000156008;
pub const VkFormat_VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16: VkFormat = 1000156009;
pub const VkFormat_VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16: VkFormat = 1000156010;
pub const VkFormat_VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16: VkFormat = 1000156011;
pub const VkFormat_VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16: VkFormat = 1000156012;
pub const VkFormat_VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16: VkFormat = 1000156013;
pub const VkFormat_VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16: VkFormat = 1000156014;
pub const VkFormat_VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16: VkFormat = 1000156015;
pub const VkFormat_VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16: VkFormat = 1000156016;
pub const VkFormat_VK_FORMAT_R12X4_UNORM_PACK16: VkFormat = 1000156017;
pub const VkFormat_VK_FORMAT_R12X4G12X4_UNORM_2PACK16: VkFormat = 1000156018;
pub const VkFormat_VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16: VkFormat = 1000156019;
pub const VkFormat_VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16: VkFormat = 1000156020;
pub const VkFormat_VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16: VkFormat = 1000156021;
pub const VkFormat_VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16: VkFormat = 1000156022;
pub const VkFormat_VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16: VkFormat = 1000156023;
pub const VkFormat_VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16: VkFormat = 1000156024;
pub const VkFormat_VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16: VkFormat = 1000156025;
pub const VkFormat_VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16: VkFormat = 1000156026;
pub const VkFormat_VK_FORMAT_G16B16G16R16_422_UNORM: VkFormat = 1000156027;
pub const VkFormat_VK_FORMAT_B16G16R16G16_422_UNORM: VkFormat = 1000156028;
pub const VkFormat_VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM: VkFormat = 1000156029;
pub const VkFormat_VK_FORMAT_G16_B16R16_2PLANE_420_UNORM: VkFormat = 1000156030;
pub const VkFormat_VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM: VkFormat = 1000156031;
pub const VkFormat_VK_FORMAT_G16_B16R16_2PLANE_422_UNORM: VkFormat = 1000156032;
pub const VkFormat_VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM: VkFormat = 1000156033;
pub const VkFormat_VK_FORMAT_G8_B8R8_2PLANE_444_UNORM: VkFormat = 1000330000;
pub const VkFormat_VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16: VkFormat = 1000330001;
pub const VkFormat_VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16: VkFormat = 1000330002;
pub const VkFormat_VK_FORMAT_G16_B16R16_2PLANE_444_UNORM: VkFormat = 1000330003;
pub const VkFormat_VK_FORMAT_A4R4G4B4_UNORM_PACK16: VkFormat = 1000340000;
pub const VkFormat_VK_FORMAT_A4B4G4R4_UNORM_PACK16: VkFormat = 1000340001;
pub const VkFormat_VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK: VkFormat = 1000066000;
pub const VkFormat_VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK: VkFormat = 1000066001;
pub const VkFormat_VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK: VkFormat = 1000066002;
pub const VkFormat_VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK: VkFormat = 1000066003;
pub const VkFormat_VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK: VkFormat = 1000066004;
pub const VkFormat_VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK: VkFormat = 1000066005;
pub const VkFormat_VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK: VkFormat = 1000066006;
pub const VkFormat_VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK: VkFormat = 1000066007;
pub const VkFormat_VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK: VkFormat = 1000066008;
pub const VkFormat_VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK: VkFormat = 1000066009;
pub const VkFormat_VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK: VkFormat = 1000066010;
pub const VkFormat_VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK: VkFormat = 1000066011;
pub const VkFormat_VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK: VkFormat = 1000066012;
pub const VkFormat_VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK: VkFormat = 1000066013;
pub const VkFormat_VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG: VkFormat = 1000054000;
pub const VkFormat_VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG: VkFormat = 1000054001;
pub const VkFormat_VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG: VkFormat = 1000054002;
pub const VkFormat_VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG: VkFormat = 1000054003;
pub const VkFormat_VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG: VkFormat = 1000054004;
pub const VkFormat_VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG: VkFormat = 1000054005;
pub const VkFormat_VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG: VkFormat = 1000054006;
pub const VkFormat_VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG: VkFormat = 1000054007;
pub const VkFormat_VK_FORMAT_R16G16_SFIXED5_NV: VkFormat = 1000464000;
pub const VkFormat_VK_FORMAT_A1B5G5R5_UNORM_PACK16_KHR: VkFormat = 1000470000;
pub const VkFormat_VK_FORMAT_A8_UNORM_KHR: VkFormat = 1000470001;
pub const VkFormat_VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT: VkFormat = 1000066000;
pub const VkFormat_VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT: VkFormat = 1000066001;
pub const VkFormat_VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT: VkFormat = 1000066002;
pub const VkFormat_VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT: VkFormat = 1000066003;
pub const VkFormat_VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT: VkFormat = 1000066004;
pub const VkFormat_VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT: VkFormat = 1000066005;
pub const VkFormat_VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT: VkFormat = 1000066006;
pub const VkFormat_VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT: VkFormat = 1000066007;
pub const VkFormat_VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT: VkFormat = 1000066008;
pub const VkFormat_VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT: VkFormat = 1000066009;
pub const VkFormat_VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT: VkFormat = 1000066010;
pub const VkFormat_VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT: VkFormat = 1000066011;
pub const VkFormat_VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT: VkFormat = 1000066012;
pub const VkFormat_VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT: VkFormat = 1000066013;
pub const VkFormat_VK_FORMAT_G8B8G8R8_422_UNORM_KHR: VkFormat = 1000156000;
pub const VkFormat_VK_FORMAT_B8G8R8G8_422_UNORM_KHR: VkFormat = 1000156001;
pub const VkFormat_VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR: VkFormat = 1000156002;
pub const VkFormat_VK_FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR: VkFormat = 1000156003;
pub const VkFormat_VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR: VkFormat = 1000156004;
pub const VkFormat_VK_FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR: VkFormat = 1000156005;
pub const VkFormat_VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR: VkFormat = 1000156006;
pub const VkFormat_VK_FORMAT_R10X6_UNORM_PACK16_KHR: VkFormat = 1000156007;
pub const VkFormat_VK_FORMAT_R10X6G10X6_UNORM_2PACK16_KHR: VkFormat = 1000156008;
pub const VkFormat_VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR: VkFormat = 1000156009;
pub const VkFormat_VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR: VkFormat = 1000156010;
pub const VkFormat_VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR: VkFormat = 1000156011;
pub const VkFormat_VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR: VkFormat = 1000156012;
pub const VkFormat_VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR: VkFormat = 1000156013;
pub const VkFormat_VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR: VkFormat = 1000156014;
pub const VkFormat_VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR: VkFormat = 1000156015;
pub const VkFormat_VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR: VkFormat = 1000156016;
pub const VkFormat_VK_FORMAT_R12X4_UNORM_PACK16_KHR: VkFormat = 1000156017;
pub const VkFormat_VK_FORMAT_R12X4G12X4_UNORM_2PACK16_KHR: VkFormat = 1000156018;
pub const VkFormat_VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR: VkFormat = 1000156019;
pub const VkFormat_VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR: VkFormat = 1000156020;
pub const VkFormat_VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR: VkFormat = 1000156021;
pub const VkFormat_VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR: VkFormat = 1000156022;
pub const VkFormat_VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR: VkFormat = 1000156023;
pub const VkFormat_VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR: VkFormat = 1000156024;
pub const VkFormat_VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR: VkFormat = 1000156025;
pub const VkFormat_VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR: VkFormat = 1000156026;
pub const VkFormat_VK_FORMAT_G16B16G16R16_422_UNORM_KHR: VkFormat = 1000156027;
pub const VkFormat_VK_FORMAT_B16G16R16G16_422_UNORM_KHR: VkFormat = 1000156028;
pub const VkFormat_VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR: VkFormat = 1000156029;
pub const VkFormat_VK_FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR: VkFormat = 1000156030;
pub const VkFormat_VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR: VkFormat = 1000156031;
pub const VkFormat_VK_FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR: VkFormat = 1000156032;
pub const VkFormat_VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR: VkFormat = 1000156033;
pub const VkFormat_VK_FORMAT_G8_B8R8_2PLANE_444_UNORM_EXT: VkFormat = 1000330000;
pub const VkFormat_VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16_EXT: VkFormat = 1000330001;
pub const VkFormat_VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16_EXT: VkFormat = 1000330002;
pub const VkFormat_VK_FORMAT_G16_B16R16_2PLANE_444_UNORM_EXT: VkFormat = 1000330003;
pub const VkFormat_VK_FORMAT_A4R4G4B4_UNORM_PACK16_EXT: VkFormat = 1000340000;
pub const VkFormat_VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT: VkFormat = 1000340001;
pub const VkFormat_VK_FORMAT_R16G16_S10_5_NV: VkFormat = 1000464000;
pub const VkFormat_VK_FORMAT_MAX_ENUM: VkFormat = 2147483647;
pub type VkFormat = ::std::os::raw::c_uint;
pub const VkImageTiling_VK_IMAGE_TILING_OPTIMAL: VkImageTiling = 0;
pub const VkImageTiling_VK_IMAGE_TILING_LINEAR: VkImageTiling = 1;
pub const VkImageTiling_VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT: VkImageTiling = 1000158000;
pub const VkImageTiling_VK_IMAGE_TILING_MAX_ENUM: VkImageTiling = 2147483647;
pub type VkImageTiling = ::std::os::raw::c_uint;
pub const VkImageType_VK_IMAGE_TYPE_1D: VkImageType = 0;
pub const VkImageType_VK_IMAGE_TYPE_2D: VkImageType = 1;
pub const VkImageType_VK_IMAGE_TYPE_3D: VkImageType = 2;
pub const VkImageType_VK_IMAGE_TYPE_MAX_ENUM: VkImageType = 2147483647;
pub type VkImageType = ::std::os::raw::c_uint;
pub const VkPhysicalDeviceType_VK_PHYSICAL_DEVICE_TYPE_OTHER: VkPhysicalDeviceType = 0;
pub const VkPhysicalDeviceType_VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU: VkPhysicalDeviceType = 1;
pub const VkPhysicalDeviceType_VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU: VkPhysicalDeviceType = 2;
pub const VkPhysicalDeviceType_VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU: VkPhysicalDeviceType = 3;
pub const VkPhysicalDeviceType_VK_PHYSICAL_DEVICE_TYPE_CPU: VkPhysicalDeviceType = 4;
pub const VkPhysicalDeviceType_VK_PHYSICAL_DEVICE_TYPE_MAX_ENUM: VkPhysicalDeviceType = 2147483647;
pub type VkPhysicalDeviceType = ::std::os::raw::c_uint;
pub const VkSharingMode_VK_SHARING_MODE_EXCLUSIVE: VkSharingMode = 0;
pub const VkSharingMode_VK_SHARING_MODE_CONCURRENT: VkSharingMode = 1;
pub const VkSharingMode_VK_SHARING_MODE_MAX_ENUM: VkSharingMode = 2147483647;
pub type VkSharingMode = ::std::os::raw::c_uint;
pub const VkImageAspectFlagBits_VK_IMAGE_ASPECT_COLOR_BIT: VkImageAspectFlagBits = 1;
pub const VkImageAspectFlagBits_VK_IMAGE_ASPECT_DEPTH_BIT: VkImageAspectFlagBits = 2;
pub const VkImageAspectFlagBits_VK_IMAGE_ASPECT_STENCIL_BIT: VkImageAspectFlagBits = 4;
pub const VkImageAspectFlagBits_VK_IMAGE_ASPECT_METADATA_BIT: VkImageAspectFlagBits = 8;
pub const VkImageAspectFlagBits_VK_IMAGE_ASPECT_PLANE_0_BIT: VkImageAspectFlagBits = 16;
pub const VkImageAspectFlagBits_VK_IMAGE_ASPECT_PLANE_1_BIT: VkImageAspectFlagBits = 32;
pub const VkImageAspectFlagBits_VK_IMAGE_ASPECT_PLANE_2_BIT: VkImageAspectFlagBits = 64;
pub const VkImageAspectFlagBits_VK_IMAGE_ASPECT_NONE: VkImageAspectFlagBits = 0;
pub const VkImageAspectFlagBits_VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT: VkImageAspectFlagBits = 128;
pub const VkImageAspectFlagBits_VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT: VkImageAspectFlagBits = 256;
pub const VkImageAspectFlagBits_VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT: VkImageAspectFlagBits = 512;
pub const VkImageAspectFlagBits_VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT: VkImageAspectFlagBits =
    1024;
pub const VkImageAspectFlagBits_VK_IMAGE_ASPECT_PLANE_0_BIT_KHR: VkImageAspectFlagBits = 16;
pub const VkImageAspectFlagBits_VK_IMAGE_ASPECT_PLANE_1_BIT_KHR: VkImageAspectFlagBits = 32;
pub const VkImageAspectFlagBits_VK_IMAGE_ASPECT_PLANE_2_BIT_KHR: VkImageAspectFlagBits = 64;
pub const VkImageAspectFlagBits_VK_IMAGE_ASPECT_NONE_KHR: VkImageAspectFlagBits = 0;
pub const VkImageAspectFlagBits_VK_IMAGE_ASPECT_FLAG_BITS_MAX_ENUM: VkImageAspectFlagBits =
    2147483647;
pub type VkImageAspectFlagBits = ::std::os::raw::c_uint;
pub type VkImageCreateFlags = VkFlags;
pub const VkSampleCountFlagBits_VK_SAMPLE_COUNT_1_BIT: VkSampleCountFlagBits = 1;
pub const VkSampleCountFlagBits_VK_SAMPLE_COUNT_2_BIT: VkSampleCountFlagBits = 2;
pub const VkSampleCountFlagBits_VK_SAMPLE_COUNT_4_BIT: VkSampleCountFlagBits = 4;
pub const VkSampleCountFlagBits_VK_SAMPLE_COUNT_8_BIT: VkSampleCountFlagBits = 8;
pub const VkSampleCountFlagBits_VK_SAMPLE_COUNT_16_BIT: VkSampleCountFlagBits = 16;
pub const VkSampleCountFlagBits_VK_SAMPLE_COUNT_32_BIT: VkSampleCountFlagBits = 32;
pub const VkSampleCountFlagBits_VK_SAMPLE_COUNT_64_BIT: VkSampleCountFlagBits = 64;
pub const VkSampleCountFlagBits_VK_SAMPLE_COUNT_FLAG_BITS_MAX_ENUM: VkSampleCountFlagBits =
    2147483647;
pub type VkSampleCountFlagBits = ::std::os::raw::c_uint;
pub type VkSampleCountFlags = VkFlags;
pub type VkImageUsageFlags = VkFlags;
pub type VkMemoryHeapFlags = VkFlags;
pub type VkMemoryPropertyFlags = VkFlags;
pub type VkMemoryMapFlags = VkFlags;
pub type VkBufferCreateFlags = VkFlags;
pub type VkBufferUsageFlags = VkFlags;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkExtent3D {
    pub width: u32,
    pub height: u32,
    pub depth: u32,
}
#[test]
fn bindgen_test_layout_VkExtent3D() {
    const UNINIT: ::std::mem::MaybeUninit<VkExtent3D> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VkExtent3D>(),
        12usize,
        concat!("Size of: ", stringify!(VkExtent3D))
    );
    assert_eq!(
        ::std::mem::align_of::<VkExtent3D>(),
        4usize,
        concat!("Alignment of ", stringify!(VkExtent3D))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkExtent3D),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VkExtent3D),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).depth) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkExtent3D),
            "::",
            stringify!(depth)
        )
    );
}
pub type PFN_vkAllocationFunction = ::std::option::Option<
    unsafe extern "C" fn(
        pUserData: *mut ::std::os::raw::c_void,
        size: usize,
        alignment: usize,
        allocationScope: VkSystemAllocationScope,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type PFN_vkFreeFunction = ::std::option::Option<
    unsafe extern "C" fn(
        pUserData: *mut ::std::os::raw::c_void,
        pMemory: *mut ::std::os::raw::c_void,
    ),
>;
pub type PFN_vkInternalAllocationNotification = ::std::option::Option<
    unsafe extern "C" fn(
        pUserData: *mut ::std::os::raw::c_void,
        size: usize,
        allocationType: VkInternalAllocationType,
        allocationScope: VkSystemAllocationScope,
    ),
>;
pub type PFN_vkInternalFreeNotification = ::std::option::Option<
    unsafe extern "C" fn(
        pUserData: *mut ::std::os::raw::c_void,
        size: usize,
        allocationType: VkInternalAllocationType,
        allocationScope: VkSystemAllocationScope,
    ),
>;
pub type PFN_vkReallocationFunction = ::std::option::Option<
    unsafe extern "C" fn(
        pUserData: *mut ::std::os::raw::c_void,
        pOriginal: *mut ::std::os::raw::c_void,
        size: usize,
        alignment: usize,
        allocationScope: VkSystemAllocationScope,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type PFN_vkVoidFunction = ::std::option::Option<unsafe extern "C" fn()>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkAllocationCallbacks {
    pub pUserData: *mut ::std::os::raw::c_void,
    pub pfnAllocation: PFN_vkAllocationFunction,
    pub pfnReallocation: PFN_vkReallocationFunction,
    pub pfnFree: PFN_vkFreeFunction,
    pub pfnInternalAllocation: PFN_vkInternalAllocationNotification,
    pub pfnInternalFree: PFN_vkInternalFreeNotification,
}
#[test]
fn bindgen_test_layout_VkAllocationCallbacks() {
    const UNINIT: ::std::mem::MaybeUninit<VkAllocationCallbacks> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VkAllocationCallbacks>(),
        48usize,
        concat!("Size of: ", stringify!(VkAllocationCallbacks))
    );
    assert_eq!(
        ::std::mem::align_of::<VkAllocationCallbacks>(),
        8usize,
        concat!("Alignment of ", stringify!(VkAllocationCallbacks))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pUserData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAllocationCallbacks),
            "::",
            stringify!(pUserData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pfnAllocation) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAllocationCallbacks),
            "::",
            stringify!(pfnAllocation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pfnReallocation) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAllocationCallbacks),
            "::",
            stringify!(pfnReallocation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pfnFree) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAllocationCallbacks),
            "::",
            stringify!(pfnFree)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pfnInternalAllocation) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAllocationCallbacks),
            "::",
            stringify!(pfnInternalAllocation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pfnInternalFree) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAllocationCallbacks),
            "::",
            stringify!(pfnInternalFree)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkMemoryHeap {
    pub size: VkDeviceSize,
    pub flags: VkMemoryHeapFlags,
}
#[test]
fn bindgen_test_layout_VkMemoryHeap() {
    const UNINIT: ::std::mem::MaybeUninit<VkMemoryHeap> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VkMemoryHeap>(),
        16usize,
        concat!("Size of: ", stringify!(VkMemoryHeap))
    );
    assert_eq!(
        ::std::mem::align_of::<VkMemoryHeap>(),
        8usize,
        concat!("Alignment of ", stringify!(VkMemoryHeap))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMemoryHeap),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMemoryHeap),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkMemoryType {
    pub propertyFlags: VkMemoryPropertyFlags,
    pub heapIndex: u32,
}
#[test]
fn bindgen_test_layout_VkMemoryType() {
    const UNINIT: ::std::mem::MaybeUninit<VkMemoryType> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VkMemoryType>(),
        8usize,
        concat!("Size of: ", stringify!(VkMemoryType))
    );
    assert_eq!(
        ::std::mem::align_of::<VkMemoryType>(),
        4usize,
        concat!("Alignment of ", stringify!(VkMemoryType))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).propertyFlags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMemoryType),
            "::",
            stringify!(propertyFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).heapIndex) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMemoryType),
            "::",
            stringify!(heapIndex)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceLimits {
    pub maxImageDimension1D: u32,
    pub maxImageDimension2D: u32,
    pub maxImageDimension3D: u32,
    pub maxImageDimensionCube: u32,
    pub maxImageArrayLayers: u32,
    pub maxTexelBufferElements: u32,
    pub maxUniformBufferRange: u32,
    pub maxStorageBufferRange: u32,
    pub maxPushConstantsSize: u32,
    pub maxMemoryAllocationCount: u32,
    pub maxSamplerAllocationCount: u32,
    pub bufferImageGranularity: VkDeviceSize,
    pub sparseAddressSpaceSize: VkDeviceSize,
    pub maxBoundDescriptorSets: u32,
    pub maxPerStageDescriptorSamplers: u32,
    pub maxPerStageDescriptorUniformBuffers: u32,
    pub maxPerStageDescriptorStorageBuffers: u32,
    pub maxPerStageDescriptorSampledImages: u32,
    pub maxPerStageDescriptorStorageImages: u32,
    pub maxPerStageDescriptorInputAttachments: u32,
    pub maxPerStageResources: u32,
    pub maxDescriptorSetSamplers: u32,
    pub maxDescriptorSetUniformBuffers: u32,
    pub maxDescriptorSetUniformBuffersDynamic: u32,
    pub maxDescriptorSetStorageBuffers: u32,
    pub maxDescriptorSetStorageBuffersDynamic: u32,
    pub maxDescriptorSetSampledImages: u32,
    pub maxDescriptorSetStorageImages: u32,
    pub maxDescriptorSetInputAttachments: u32,
    pub maxVertexInputAttributes: u32,
    pub maxVertexInputBindings: u32,
    pub maxVertexInputAttributeOffset: u32,
    pub maxVertexInputBindingStride: u32,
    pub maxVertexOutputComponents: u32,
    pub maxTessellationGenerationLevel: u32,
    pub maxTessellationPatchSize: u32,
    pub maxTessellationControlPerVertexInputComponents: u32,
    pub maxTessellationControlPerVertexOutputComponents: u32,
    pub maxTessellationControlPerPatchOutputComponents: u32,
    pub maxTessellationControlTotalOutputComponents: u32,
    pub maxTessellationEvaluationInputComponents: u32,
    pub maxTessellationEvaluationOutputComponents: u32,
    pub maxGeometryShaderInvocations: u32,
    pub maxGeometryInputComponents: u32,
    pub maxGeometryOutputComponents: u32,
    pub maxGeometryOutputVertices: u32,
    pub maxGeometryTotalOutputComponents: u32,
    pub maxFragmentInputComponents: u32,
    pub maxFragmentOutputAttachments: u32,
    pub maxFragmentDualSrcAttachments: u32,
    pub maxFragmentCombinedOutputResources: u32,
    pub maxComputeSharedMemorySize: u32,
    pub maxComputeWorkGroupCount: [u32; 3usize],
    pub maxComputeWorkGroupInvocations: u32,
    pub maxComputeWorkGroupSize: [u32; 3usize],
    pub subPixelPrecisionBits: u32,
    pub subTexelPrecisionBits: u32,
    pub mipmapPrecisionBits: u32,
    pub maxDrawIndexedIndexValue: u32,
    pub maxDrawIndirectCount: u32,
    pub maxSamplerLodBias: f32,
    pub maxSamplerAnisotropy: f32,
    pub maxViewports: u32,
    pub maxViewportDimensions: [u32; 2usize],
    pub viewportBoundsRange: [f32; 2usize],
    pub viewportSubPixelBits: u32,
    pub minMemoryMapAlignment: usize,
    pub minTexelBufferOffsetAlignment: VkDeviceSize,
    pub minUniformBufferOffsetAlignment: VkDeviceSize,
    pub minStorageBufferOffsetAlignment: VkDeviceSize,
    pub minTexelOffset: i32,
    pub maxTexelOffset: u32,
    pub minTexelGatherOffset: i32,
    pub maxTexelGatherOffset: u32,
    pub minInterpolationOffset: f32,
    pub maxInterpolationOffset: f32,
    pub subPixelInterpolationOffsetBits: u32,
    pub maxFramebufferWidth: u32,
    pub maxFramebufferHeight: u32,
    pub maxFramebufferLayers: u32,
    pub framebufferColorSampleCounts: VkSampleCountFlags,
    pub framebufferDepthSampleCounts: VkSampleCountFlags,
    pub framebufferStencilSampleCounts: VkSampleCountFlags,
    pub framebufferNoAttachmentsSampleCounts: VkSampleCountFlags,
    pub maxColorAttachments: u32,
    pub sampledImageColorSampleCounts: VkSampleCountFlags,
    pub sampledImageIntegerSampleCounts: VkSampleCountFlags,
    pub sampledImageDepthSampleCounts: VkSampleCountFlags,
    pub sampledImageStencilSampleCounts: VkSampleCountFlags,
    pub storageImageSampleCounts: VkSampleCountFlags,
    pub maxSampleMaskWords: u32,
    pub timestampComputeAndGraphics: VkBool32,
    pub timestampPeriod: f32,
    pub maxClipDistances: u32,
    pub maxCullDistances: u32,
    pub maxCombinedClipAndCullDistances: u32,
    pub discreteQueuePriorities: u32,
    pub pointSizeRange: [f32; 2usize],
    pub lineWidthRange: [f32; 2usize],
    pub pointSizeGranularity: f32,
    pub lineWidthGranularity: f32,
    pub strictLines: VkBool32,
    pub standardSampleLocations: VkBool32,
    pub optimalBufferCopyOffsetAlignment: VkDeviceSize,
    pub optimalBufferCopyRowPitchAlignment: VkDeviceSize,
    pub nonCoherentAtomSize: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceLimits() {
    const UNINIT: ::std::mem::MaybeUninit<VkPhysicalDeviceLimits> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceLimits>(),
        504usize,
        concat!("Size of: ", stringify!(VkPhysicalDeviceLimits))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceLimits>(),
        8usize,
        concat!("Alignment of ", stringify!(VkPhysicalDeviceLimits))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxImageDimension1D) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxImageDimension1D)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxImageDimension2D) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxImageDimension2D)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxImageDimension3D) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxImageDimension3D)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxImageDimensionCube) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxImageDimensionCube)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxImageArrayLayers) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxImageArrayLayers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxTexelBufferElements) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxTexelBufferElements)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxUniformBufferRange) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxUniformBufferRange)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxStorageBufferRange) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxStorageBufferRange)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxPushConstantsSize) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxPushConstantsSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxMemoryAllocationCount) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxMemoryAllocationCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxSamplerAllocationCount) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxSamplerAllocationCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bufferImageGranularity) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(bufferImageGranularity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sparseAddressSpaceSize) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(sparseAddressSpaceSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxBoundDescriptorSets) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxBoundDescriptorSets)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).maxPerStageDescriptorSamplers) as usize - ptr as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxPerStageDescriptorSamplers)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).maxPerStageDescriptorUniformBuffers) as usize - ptr as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxPerStageDescriptorUniformBuffers)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).maxPerStageDescriptorStorageBuffers) as usize - ptr as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxPerStageDescriptorStorageBuffers)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).maxPerStageDescriptorSampledImages) as usize - ptr as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxPerStageDescriptorSampledImages)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).maxPerStageDescriptorStorageImages) as usize - ptr as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxPerStageDescriptorStorageImages)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).maxPerStageDescriptorInputAttachments) as usize
                - ptr as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxPerStageDescriptorInputAttachments)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxPerStageResources) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxPerStageResources)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxDescriptorSetSamplers) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxDescriptorSetSamplers)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).maxDescriptorSetUniformBuffers) as usize - ptr as usize
        },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxDescriptorSetUniformBuffers)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).maxDescriptorSetUniformBuffersDynamic) as usize
                - ptr as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxDescriptorSetUniformBuffersDynamic)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).maxDescriptorSetStorageBuffers) as usize - ptr as usize
        },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxDescriptorSetStorageBuffers)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).maxDescriptorSetStorageBuffersDynamic) as usize
                - ptr as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxDescriptorSetStorageBuffersDynamic)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).maxDescriptorSetSampledImages) as usize - ptr as usize
        },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxDescriptorSetSampledImages)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).maxDescriptorSetStorageImages) as usize - ptr as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxDescriptorSetStorageImages)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).maxDescriptorSetInputAttachments) as usize - ptr as usize
        },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxDescriptorSetInputAttachments)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxVertexInputAttributes) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxVertexInputAttributes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxVertexInputBindings) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxVertexInputBindings)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).maxVertexInputAttributeOffset) as usize - ptr as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxVertexInputAttributeOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxVertexInputBindingStride) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxVertexInputBindingStride)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxVertexOutputComponents) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxVertexOutputComponents)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).maxTessellationGenerationLevel) as usize - ptr as usize
        },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxTessellationGenerationLevel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxTessellationPatchSize) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxTessellationPatchSize)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).maxTessellationControlPerVertexInputComponents) as usize
                - ptr as usize
        },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxTessellationControlPerVertexInputComponents)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).maxTessellationControlPerVertexOutputComponents) as usize
                - ptr as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxTessellationControlPerVertexOutputComponents)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).maxTessellationControlPerPatchOutputComponents) as usize
                - ptr as usize
        },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxTessellationControlPerPatchOutputComponents)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).maxTessellationControlTotalOutputComponents) as usize
                - ptr as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxTessellationControlTotalOutputComponents)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).maxTessellationEvaluationInputComponents) as usize
                - ptr as usize
        },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxTessellationEvaluationInputComponents)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).maxTessellationEvaluationOutputComponents) as usize
                - ptr as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxTessellationEvaluationOutputComponents)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).maxGeometryShaderInvocations) as usize - ptr as usize
        },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxGeometryShaderInvocations)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxGeometryInputComponents) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxGeometryInputComponents)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxGeometryOutputComponents) as usize - ptr as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxGeometryOutputComponents)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxGeometryOutputVertices) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxGeometryOutputVertices)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).maxGeometryTotalOutputComponents) as usize - ptr as usize
        },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxGeometryTotalOutputComponents)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxFragmentInputComponents) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxFragmentInputComponents)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).maxFragmentOutputAttachments) as usize - ptr as usize
        },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxFragmentOutputAttachments)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).maxFragmentDualSrcAttachments) as usize - ptr as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxFragmentDualSrcAttachments)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).maxFragmentCombinedOutputResources) as usize - ptr as usize
        },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxFragmentCombinedOutputResources)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxComputeSharedMemorySize) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxComputeSharedMemorySize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxComputeWorkGroupCount) as usize - ptr as usize },
        220usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxComputeWorkGroupCount)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).maxComputeWorkGroupInvocations) as usize - ptr as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxComputeWorkGroupInvocations)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxComputeWorkGroupSize) as usize - ptr as usize },
        236usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxComputeWorkGroupSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subPixelPrecisionBits) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(subPixelPrecisionBits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subTexelPrecisionBits) as usize - ptr as usize },
        252usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(subTexelPrecisionBits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mipmapPrecisionBits) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(mipmapPrecisionBits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxDrawIndexedIndexValue) as usize - ptr as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxDrawIndexedIndexValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxDrawIndirectCount) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxDrawIndirectCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxSamplerLodBias) as usize - ptr as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxSamplerLodBias)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxSamplerAnisotropy) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxSamplerAnisotropy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxViewports) as usize - ptr as usize },
        276usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxViewports)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxViewportDimensions) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxViewportDimensions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).viewportBoundsRange) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(viewportBoundsRange)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).viewportSubPixelBits) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(viewportSubPixelBits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minMemoryMapAlignment) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(minMemoryMapAlignment)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).minTexelBufferOffsetAlignment) as usize - ptr as usize
        },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(minTexelBufferOffsetAlignment)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).minUniformBufferOffsetAlignment) as usize - ptr as usize
        },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(minUniformBufferOffsetAlignment)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).minStorageBufferOffsetAlignment) as usize - ptr as usize
        },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(minStorageBufferOffsetAlignment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minTexelOffset) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(minTexelOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxTexelOffset) as usize - ptr as usize },
        340usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxTexelOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minTexelGatherOffset) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(minTexelGatherOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxTexelGatherOffset) as usize - ptr as usize },
        348usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxTexelGatherOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minInterpolationOffset) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(minInterpolationOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxInterpolationOffset) as usize - ptr as usize },
        356usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxInterpolationOffset)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).subPixelInterpolationOffsetBits) as usize - ptr as usize
        },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(subPixelInterpolationOffsetBits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxFramebufferWidth) as usize - ptr as usize },
        364usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxFramebufferWidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxFramebufferHeight) as usize - ptr as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxFramebufferHeight)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxFramebufferLayers) as usize - ptr as usize },
        372usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxFramebufferLayers)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).framebufferColorSampleCounts) as usize - ptr as usize
        },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(framebufferColorSampleCounts)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).framebufferDepthSampleCounts) as usize - ptr as usize
        },
        380usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(framebufferDepthSampleCounts)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).framebufferStencilSampleCounts) as usize - ptr as usize
        },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(framebufferStencilSampleCounts)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).framebufferNoAttachmentsSampleCounts) as usize
                - ptr as usize
        },
        388usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(framebufferNoAttachmentsSampleCounts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxColorAttachments) as usize - ptr as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxColorAttachments)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).sampledImageColorSampleCounts) as usize - ptr as usize
        },
        396usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(sampledImageColorSampleCounts)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).sampledImageIntegerSampleCounts) as usize - ptr as usize
        },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(sampledImageIntegerSampleCounts)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).sampledImageDepthSampleCounts) as usize - ptr as usize
        },
        404usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(sampledImageDepthSampleCounts)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).sampledImageStencilSampleCounts) as usize - ptr as usize
        },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(sampledImageStencilSampleCounts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).storageImageSampleCounts) as usize - ptr as usize },
        412usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(storageImageSampleCounts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxSampleMaskWords) as usize - ptr as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxSampleMaskWords)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestampComputeAndGraphics) as usize - ptr as usize },
        420usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(timestampComputeAndGraphics)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestampPeriod) as usize - ptr as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(timestampPeriod)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxClipDistances) as usize - ptr as usize },
        428usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxClipDistances)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxCullDistances) as usize - ptr as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxCullDistances)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).maxCombinedClipAndCullDistances) as usize - ptr as usize
        },
        436usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxCombinedClipAndCullDistances)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).discreteQueuePriorities) as usize - ptr as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(discreteQueuePriorities)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pointSizeRange) as usize - ptr as usize },
        444usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(pointSizeRange)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lineWidthRange) as usize - ptr as usize },
        452usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(lineWidthRange)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pointSizeGranularity) as usize - ptr as usize },
        460usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(pointSizeGranularity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lineWidthGranularity) as usize - ptr as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(lineWidthGranularity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).strictLines) as usize - ptr as usize },
        468usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(strictLines)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).standardSampleLocations) as usize - ptr as usize },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(standardSampleLocations)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).optimalBufferCopyOffsetAlignment) as usize - ptr as usize
        },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(optimalBufferCopyOffsetAlignment)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).optimalBufferCopyRowPitchAlignment) as usize - ptr as usize
        },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(optimalBufferCopyRowPitchAlignment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nonCoherentAtomSize) as usize - ptr as usize },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(nonCoherentAtomSize)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceMemoryProperties {
    pub memoryTypeCount: u32,
    pub memoryTypes: [VkMemoryType; 32usize],
    pub memoryHeapCount: u32,
    pub memoryHeaps: [VkMemoryHeap; 16usize],
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceMemoryProperties() {
    const UNINIT: ::std::mem::MaybeUninit<VkPhysicalDeviceMemoryProperties> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceMemoryProperties>(),
        520usize,
        concat!("Size of: ", stringify!(VkPhysicalDeviceMemoryProperties))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceMemoryProperties>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceMemoryProperties)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memoryTypeCount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceMemoryProperties),
            "::",
            stringify!(memoryTypeCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memoryTypes) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceMemoryProperties),
            "::",
            stringify!(memoryTypes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memoryHeapCount) as usize - ptr as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceMemoryProperties),
            "::",
            stringify!(memoryHeapCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memoryHeaps) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceMemoryProperties),
            "::",
            stringify!(memoryHeaps)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceSparseProperties {
    pub residencyStandard2DBlockShape: VkBool32,
    pub residencyStandard2DMultisampleBlockShape: VkBool32,
    pub residencyStandard3DBlockShape: VkBool32,
    pub residencyAlignedMipSize: VkBool32,
    pub residencyNonResidentStrict: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceSparseProperties() {
    const UNINIT: ::std::mem::MaybeUninit<VkPhysicalDeviceSparseProperties> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceSparseProperties>(),
        20usize,
        concat!("Size of: ", stringify!(VkPhysicalDeviceSparseProperties))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceSparseProperties>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceSparseProperties)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).residencyStandard2DBlockShape) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceSparseProperties),
            "::",
            stringify!(residencyStandard2DBlockShape)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).residencyStandard2DMultisampleBlockShape) as usize
                - ptr as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceSparseProperties),
            "::",
            stringify!(residencyStandard2DMultisampleBlockShape)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).residencyStandard3DBlockShape) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceSparseProperties),
            "::",
            stringify!(residencyStandard3DBlockShape)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).residencyAlignedMipSize) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceSparseProperties),
            "::",
            stringify!(residencyAlignedMipSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).residencyNonResidentStrict) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceSparseProperties),
            "::",
            stringify!(residencyNonResidentStrict)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceProperties {
    pub apiVersion: u32,
    pub driverVersion: u32,
    pub vendorID: u32,
    pub deviceID: u32,
    pub deviceType: VkPhysicalDeviceType,
    pub deviceName: [::std::os::raw::c_char; 256usize],
    pub pipelineCacheUUID: [u8; 16usize],
    pub limits: VkPhysicalDeviceLimits,
    pub sparseProperties: VkPhysicalDeviceSparseProperties,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceProperties() {
    const UNINIT: ::std::mem::MaybeUninit<VkPhysicalDeviceProperties> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceProperties>(),
        824usize,
        concat!("Size of: ", stringify!(VkPhysicalDeviceProperties))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceProperties>(),
        8usize,
        concat!("Alignment of ", stringify!(VkPhysicalDeviceProperties))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).apiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceProperties),
            "::",
            stringify!(apiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).driverVersion) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceProperties),
            "::",
            stringify!(driverVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vendorID) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceProperties),
            "::",
            stringify!(vendorID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deviceID) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceProperties),
            "::",
            stringify!(deviceID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deviceType) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceProperties),
            "::",
            stringify!(deviceType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deviceName) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceProperties),
            "::",
            stringify!(deviceName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pipelineCacheUUID) as usize - ptr as usize },
        276usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceProperties),
            "::",
            stringify!(pipelineCacheUUID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).limits) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceProperties),
            "::",
            stringify!(limits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sparseProperties) as usize - ptr as usize },
        800usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceProperties),
            "::",
            stringify!(sparseProperties)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkMappedMemoryRange {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub memory: VkDeviceMemory,
    pub offset: VkDeviceSize,
    pub size: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VkMappedMemoryRange() {
    const UNINIT: ::std::mem::MaybeUninit<VkMappedMemoryRange> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VkMappedMemoryRange>(),
        40usize,
        concat!("Size of: ", stringify!(VkMappedMemoryRange))
    );
    assert_eq!(
        ::std::mem::align_of::<VkMappedMemoryRange>(),
        8usize,
        concat!("Alignment of ", stringify!(VkMappedMemoryRange))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMappedMemoryRange),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMappedMemoryRange),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memory) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMappedMemoryRange),
            "::",
            stringify!(memory)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMappedMemoryRange),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMappedMemoryRange),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkMemoryAllocateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub allocationSize: VkDeviceSize,
    pub memoryTypeIndex: u32,
}
#[test]
fn bindgen_test_layout_VkMemoryAllocateInfo() {
    const UNINIT: ::std::mem::MaybeUninit<VkMemoryAllocateInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VkMemoryAllocateInfo>(),
        32usize,
        concat!("Size of: ", stringify!(VkMemoryAllocateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkMemoryAllocateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkMemoryAllocateInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMemoryAllocateInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMemoryAllocateInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocationSize) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMemoryAllocateInfo),
            "::",
            stringify!(allocationSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memoryTypeIndex) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMemoryAllocateInfo),
            "::",
            stringify!(memoryTypeIndex)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkMemoryRequirements {
    pub size: VkDeviceSize,
    pub alignment: VkDeviceSize,
    pub memoryTypeBits: u32,
}
#[test]
fn bindgen_test_layout_VkMemoryRequirements() {
    const UNINIT: ::std::mem::MaybeUninit<VkMemoryRequirements> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VkMemoryRequirements>(),
        24usize,
        concat!("Size of: ", stringify!(VkMemoryRequirements))
    );
    assert_eq!(
        ::std::mem::align_of::<VkMemoryRequirements>(),
        8usize,
        concat!("Alignment of ", stringify!(VkMemoryRequirements))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMemoryRequirements),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alignment) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMemoryRequirements),
            "::",
            stringify!(alignment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memoryTypeBits) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMemoryRequirements),
            "::",
            stringify!(memoryTypeBits)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkBufferCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkBufferCreateFlags,
    pub size: VkDeviceSize,
    pub usage: VkBufferUsageFlags,
    pub sharingMode: VkSharingMode,
    pub queueFamilyIndexCount: u32,
    pub pQueueFamilyIndices: *const u32,
}
#[test]
fn bindgen_test_layout_VkBufferCreateInfo() {
    const UNINIT: ::std::mem::MaybeUninit<VkBufferCreateInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VkBufferCreateInfo>(),
        56usize,
        concat!("Size of: ", stringify!(VkBufferCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkBufferCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkBufferCreateInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBufferCreateInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBufferCreateInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBufferCreateInfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBufferCreateInfo),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).usage) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBufferCreateInfo),
            "::",
            stringify!(usage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sharingMode) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBufferCreateInfo),
            "::",
            stringify!(sharingMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).queueFamilyIndexCount) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBufferCreateInfo),
            "::",
            stringify!(queueFamilyIndexCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pQueueFamilyIndices) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBufferCreateInfo),
            "::",
            stringify!(pQueueFamilyIndices)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImageCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkImageCreateFlags,
    pub imageType: VkImageType,
    pub format: VkFormat,
    pub extent: VkExtent3D,
    pub mipLevels: u32,
    pub arrayLayers: u32,
    pub samples: VkSampleCountFlagBits,
    pub tiling: VkImageTiling,
    pub usage: VkImageUsageFlags,
    pub sharingMode: VkSharingMode,
    pub queueFamilyIndexCount: u32,
    pub pQueueFamilyIndices: *const u32,
    pub initialLayout: VkImageLayout,
}
#[test]
fn bindgen_test_layout_VkImageCreateInfo() {
    const UNINIT: ::std::mem::MaybeUninit<VkImageCreateInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VkImageCreateInfo>(),
        88usize,
        concat!("Size of: ", stringify!(VkImageCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkImageCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkImageCreateInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageCreateInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageCreateInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageCreateInfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imageType) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageCreateInfo),
            "::",
            stringify!(imageType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageCreateInfo),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extent) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageCreateInfo),
            "::",
            stringify!(extent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mipLevels) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageCreateInfo),
            "::",
            stringify!(mipLevels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arrayLayers) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageCreateInfo),
            "::",
            stringify!(arrayLayers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).samples) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageCreateInfo),
            "::",
            stringify!(samples)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tiling) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageCreateInfo),
            "::",
            stringify!(tiling)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).usage) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageCreateInfo),
            "::",
            stringify!(usage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sharingMode) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageCreateInfo),
            "::",
            stringify!(sharingMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).queueFamilyIndexCount) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageCreateInfo),
            "::",
            stringify!(queueFamilyIndexCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pQueueFamilyIndices) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageCreateInfo),
            "::",
            stringify!(pQueueFamilyIndices)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initialLayout) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageCreateInfo),
            "::",
            stringify!(initialLayout)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkBufferCopy {
    pub srcOffset: VkDeviceSize,
    pub dstOffset: VkDeviceSize,
    pub size: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VkBufferCopy() {
    const UNINIT: ::std::mem::MaybeUninit<VkBufferCopy> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VkBufferCopy>(),
        24usize,
        concat!("Size of: ", stringify!(VkBufferCopy))
    );
    assert_eq!(
        ::std::mem::align_of::<VkBufferCopy>(),
        8usize,
        concat!("Alignment of ", stringify!(VkBufferCopy))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srcOffset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBufferCopy),
            "::",
            stringify!(srcOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dstOffset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBufferCopy),
            "::",
            stringify!(dstOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBufferCopy),
            "::",
            stringify!(size)
        )
    );
}
pub type PFN_vkGetPhysicalDeviceProperties = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pProperties: *mut VkPhysicalDeviceProperties,
    ),
>;
pub type PFN_vkGetPhysicalDeviceMemoryProperties = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pMemoryProperties: *mut VkPhysicalDeviceMemoryProperties,
    ),
>;
pub type PFN_vkGetInstanceProcAddr = ::std::option::Option<
    unsafe extern "C" fn(
        instance: VkInstance,
        pName: *const ::std::os::raw::c_char,
    ) -> PFN_vkVoidFunction,
>;
pub type PFN_vkGetDeviceProcAddr = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pName: *const ::std::os::raw::c_char,
    ) -> PFN_vkVoidFunction,
>;
pub type PFN_vkAllocateMemory = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pAllocateInfo: *const VkMemoryAllocateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pMemory: *mut VkDeviceMemory,
    ) -> VkResult,
>;
pub type PFN_vkFreeMemory = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        memory: VkDeviceMemory,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkMapMemory = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        memory: VkDeviceMemory,
        offset: VkDeviceSize,
        size: VkDeviceSize,
        flags: VkMemoryMapFlags,
        ppData: *mut *mut ::std::os::raw::c_void,
    ) -> VkResult,
>;
pub type PFN_vkUnmapMemory =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice, memory: VkDeviceMemory)>;
pub type PFN_vkFlushMappedMemoryRanges = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        memoryRangeCount: u32,
        pMemoryRanges: *const VkMappedMemoryRange,
    ) -> VkResult,
>;
pub type PFN_vkInvalidateMappedMemoryRanges = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        memoryRangeCount: u32,
        pMemoryRanges: *const VkMappedMemoryRange,
    ) -> VkResult,
>;
pub type PFN_vkBindBufferMemory = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        buffer: VkBuffer,
        memory: VkDeviceMemory,
        memoryOffset: VkDeviceSize,
    ) -> VkResult,
>;
pub type PFN_vkBindImageMemory = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        image: VkImage,
        memory: VkDeviceMemory,
        memoryOffset: VkDeviceSize,
    ) -> VkResult,
>;
pub type PFN_vkGetBufferMemoryRequirements = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        buffer: VkBuffer,
        pMemoryRequirements: *mut VkMemoryRequirements,
    ),
>;
pub type PFN_vkGetImageMemoryRequirements = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        image: VkImage,
        pMemoryRequirements: *mut VkMemoryRequirements,
    ),
>;
pub type PFN_vkCreateBuffer = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkBufferCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pBuffer: *mut VkBuffer,
    ) -> VkResult,
>;
pub type PFN_vkDestroyBuffer = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        buffer: VkBuffer,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkCreateImage = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkImageCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pImage: *mut VkImage,
    ) -> VkResult,
>;
pub type PFN_vkDestroyImage = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        image: VkImage,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkCmdCopyBuffer = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        srcBuffer: VkBuffer,
        dstBuffer: VkBuffer,
        regionCount: u32,
        pRegions: *const VkBufferCopy,
    ),
>;
pub type VkExternalMemoryHandleTypeFlags = VkFlags;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkBindBufferMemoryInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub buffer: VkBuffer,
    pub memory: VkDeviceMemory,
    pub memoryOffset: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VkBindBufferMemoryInfo() {
    const UNINIT: ::std::mem::MaybeUninit<VkBindBufferMemoryInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VkBindBufferMemoryInfo>(),
        40usize,
        concat!("Size of: ", stringify!(VkBindBufferMemoryInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkBindBufferMemoryInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkBindBufferMemoryInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBindBufferMemoryInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBindBufferMemoryInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBindBufferMemoryInfo),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memory) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBindBufferMemoryInfo),
            "::",
            stringify!(memory)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memoryOffset) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBindBufferMemoryInfo),
            "::",
            stringify!(memoryOffset)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkBindImageMemoryInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub image: VkImage,
    pub memory: VkDeviceMemory,
    pub memoryOffset: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VkBindImageMemoryInfo() {
    const UNINIT: ::std::mem::MaybeUninit<VkBindImageMemoryInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VkBindImageMemoryInfo>(),
        40usize,
        concat!("Size of: ", stringify!(VkBindImageMemoryInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkBindImageMemoryInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkBindImageMemoryInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBindImageMemoryInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBindImageMemoryInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).image) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBindImageMemoryInfo),
            "::",
            stringify!(image)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memory) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBindImageMemoryInfo),
            "::",
            stringify!(memory)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memoryOffset) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBindImageMemoryInfo),
            "::",
            stringify!(memoryOffset)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkBufferMemoryRequirementsInfo2 {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub buffer: VkBuffer,
}
#[test]
fn bindgen_test_layout_VkBufferMemoryRequirementsInfo2() {
    const UNINIT: ::std::mem::MaybeUninit<VkBufferMemoryRequirementsInfo2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VkBufferMemoryRequirementsInfo2>(),
        24usize,
        concat!("Size of: ", stringify!(VkBufferMemoryRequirementsInfo2))
    );
    assert_eq!(
        ::std::mem::align_of::<VkBufferMemoryRequirementsInfo2>(),
        8usize,
        concat!("Alignment of ", stringify!(VkBufferMemoryRequirementsInfo2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBufferMemoryRequirementsInfo2),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBufferMemoryRequirementsInfo2),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBufferMemoryRequirementsInfo2),
            "::",
            stringify!(buffer)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImageMemoryRequirementsInfo2 {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub image: VkImage,
}
#[test]
fn bindgen_test_layout_VkImageMemoryRequirementsInfo2() {
    const UNINIT: ::std::mem::MaybeUninit<VkImageMemoryRequirementsInfo2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VkImageMemoryRequirementsInfo2>(),
        24usize,
        concat!("Size of: ", stringify!(VkImageMemoryRequirementsInfo2))
    );
    assert_eq!(
        ::std::mem::align_of::<VkImageMemoryRequirementsInfo2>(),
        8usize,
        concat!("Alignment of ", stringify!(VkImageMemoryRequirementsInfo2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageMemoryRequirementsInfo2),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageMemoryRequirementsInfo2),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).image) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageMemoryRequirementsInfo2),
            "::",
            stringify!(image)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkMemoryRequirements2 {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub memoryRequirements: VkMemoryRequirements,
}
#[test]
fn bindgen_test_layout_VkMemoryRequirements2() {
    const UNINIT: ::std::mem::MaybeUninit<VkMemoryRequirements2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VkMemoryRequirements2>(),
        40usize,
        concat!("Size of: ", stringify!(VkMemoryRequirements2))
    );
    assert_eq!(
        ::std::mem::align_of::<VkMemoryRequirements2>(),
        8usize,
        concat!("Alignment of ", stringify!(VkMemoryRequirements2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMemoryRequirements2),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMemoryRequirements2),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memoryRequirements) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMemoryRequirements2),
            "::",
            stringify!(memoryRequirements)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceMemoryProperties2 {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub memoryProperties: VkPhysicalDeviceMemoryProperties,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceMemoryProperties2() {
    const UNINIT: ::std::mem::MaybeUninit<VkPhysicalDeviceMemoryProperties2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceMemoryProperties2>(),
        536usize,
        concat!("Size of: ", stringify!(VkPhysicalDeviceMemoryProperties2))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceMemoryProperties2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceMemoryProperties2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceMemoryProperties2),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceMemoryProperties2),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memoryProperties) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceMemoryProperties2),
            "::",
            stringify!(memoryProperties)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDeviceBufferMemoryRequirements {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub pCreateInfo: *const VkBufferCreateInfo,
}
#[test]
fn bindgen_test_layout_VkDeviceBufferMemoryRequirements() {
    const UNINIT: ::std::mem::MaybeUninit<VkDeviceBufferMemoryRequirements> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VkDeviceBufferMemoryRequirements>(),
        24usize,
        concat!("Size of: ", stringify!(VkDeviceBufferMemoryRequirements))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDeviceBufferMemoryRequirements>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkDeviceBufferMemoryRequirements)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceBufferMemoryRequirements),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceBufferMemoryRequirements),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pCreateInfo) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceBufferMemoryRequirements),
            "::",
            stringify!(pCreateInfo)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDeviceImageMemoryRequirements {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub pCreateInfo: *const VkImageCreateInfo,
    pub planeAspect: VkImageAspectFlagBits,
}
#[test]
fn bindgen_test_layout_VkDeviceImageMemoryRequirements() {
    const UNINIT: ::std::mem::MaybeUninit<VkDeviceImageMemoryRequirements> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VkDeviceImageMemoryRequirements>(),
        32usize,
        concat!("Size of: ", stringify!(VkDeviceImageMemoryRequirements))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDeviceImageMemoryRequirements>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDeviceImageMemoryRequirements))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceImageMemoryRequirements),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceImageMemoryRequirements),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pCreateInfo) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceImageMemoryRequirements),
            "::",
            stringify!(pCreateInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).planeAspect) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceImageMemoryRequirements),
            "::",
            stringify!(planeAspect)
        )
    );
}
pub type PFN_vkGetPhysicalDeviceMemoryProperties2KHR = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pMemoryProperties: *mut VkPhysicalDeviceMemoryProperties2,
    ),
>;
pub type VkExternalMemoryHandleTypeFlagsKHR = VkExternalMemoryHandleTypeFlags;
pub type PFN_vkGetImageMemoryRequirements2KHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pInfo: *const VkImageMemoryRequirementsInfo2,
        pMemoryRequirements: *mut VkMemoryRequirements2,
    ),
>;
pub type PFN_vkGetBufferMemoryRequirements2KHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pInfo: *const VkBufferMemoryRequirementsInfo2,
        pMemoryRequirements: *mut VkMemoryRequirements2,
    ),
>;
pub type PFN_vkBindBufferMemory2KHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        bindInfoCount: u32,
        pBindInfos: *const VkBindBufferMemoryInfo,
    ) -> VkResult,
>;
pub type PFN_vkBindImageMemory2KHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        bindInfoCount: u32,
        pBindInfos: *const VkBindImageMemoryInfo,
    ) -> VkResult,
>;
pub type PFN_vkGetDeviceBufferMemoryRequirementsKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pInfo: *const VkDeviceBufferMemoryRequirements,
        pMemoryRequirements: *mut VkMemoryRequirements2,
    ),
>;
pub type PFN_vkGetDeviceImageMemoryRequirementsKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pInfo: *const VkDeviceImageMemoryRequirements,
        pMemoryRequirements: *mut VkMemoryRequirements2,
    ),
>;
#[doc = " See #VmaAllocatorCreateFlagBits."]
pub type VmaAllocatorCreateFlags = VkFlags;
#[doc = " No intended memory usage specified.\nUse other members of VmaAllocationCreateInfo to specify your requirements."]
pub const VmaMemoryUsage_VMA_MEMORY_USAGE_UNKNOWN: VmaMemoryUsage = 0;
#[doc = "\\deprecated Obsolete, preserved for backward compatibility.\nPrefers `VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT`."]
pub const VmaMemoryUsage_VMA_MEMORY_USAGE_GPU_ONLY: VmaMemoryUsage = 1;
#[doc = "\\deprecated Obsolete, preserved for backward compatibility.\nGuarantees `VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT` and `VK_MEMORY_PROPERTY_HOST_COHERENT_BIT`."]
pub const VmaMemoryUsage_VMA_MEMORY_USAGE_CPU_ONLY: VmaMemoryUsage = 2;
#[doc = "\\deprecated Obsolete, preserved for backward compatibility.\nGuarantees `VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT`, prefers `VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT`."]
pub const VmaMemoryUsage_VMA_MEMORY_USAGE_CPU_TO_GPU: VmaMemoryUsage = 3;
#[doc = "\\deprecated Obsolete, preserved for backward compatibility.\nGuarantees `VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT`, prefers `VK_MEMORY_PROPERTY_HOST_CACHED_BIT`."]
pub const VmaMemoryUsage_VMA_MEMORY_USAGE_GPU_TO_CPU: VmaMemoryUsage = 4;
#[doc = "\\deprecated Obsolete, preserved for backward compatibility.\nPrefers not `VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT`."]
pub const VmaMemoryUsage_VMA_MEMORY_USAGE_CPU_COPY: VmaMemoryUsage = 5;
#[doc = "Lazily allocated GPU memory having `VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT`.\nExists mostly on mobile platforms. Using it on desktop PC or other GPUs with no such memory type present will fail the allocation.\n\nUsage: Memory for transient attachment images (color attachments, depth attachments etc.), created with `VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT`.\n\nAllocations with this usage are always created as dedicated - it implies #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT."]
pub const VmaMemoryUsage_VMA_MEMORY_USAGE_GPU_LAZILY_ALLOCATED: VmaMemoryUsage = 6;
#[doc = "Selects best memory type automatically.\nThis flag is recommended for most common use cases.\n\nWhen using this flag, if you want to map the allocation (using vmaMapMemory() or #VMA_ALLOCATION_CREATE_MAPPED_BIT),\nyou must pass one of the flags: #VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT or #VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT\nin VmaAllocationCreateInfo::flags.\n\nIt can be used only with functions that let the library know `VkBufferCreateInfo` or `VkImageCreateInfo`, e.g.\nvmaCreateBuffer(), vmaCreateImage(), vmaFindMemoryTypeIndexForBufferInfo(), vmaFindMemoryTypeIndexForImageInfo()\nand not with generic memory allocation functions."]
pub const VmaMemoryUsage_VMA_MEMORY_USAGE_AUTO: VmaMemoryUsage = 7;
#[doc = "Selects best memory type automatically with preference for GPU (device) memory.\n\nWhen using this flag, if you want to map the allocation (using vmaMapMemory() or #VMA_ALLOCATION_CREATE_MAPPED_BIT),\nyou must pass one of the flags: #VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT or #VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT\nin VmaAllocationCreateInfo::flags.\n\nIt can be used only with functions that let the library know `VkBufferCreateInfo` or `VkImageCreateInfo`, e.g.\nvmaCreateBuffer(), vmaCreateImage(), vmaFindMemoryTypeIndexForBufferInfo(), vmaFindMemoryTypeIndexForImageInfo()\nand not with generic memory allocation functions."]
pub const VmaMemoryUsage_VMA_MEMORY_USAGE_AUTO_PREFER_DEVICE: VmaMemoryUsage = 8;
#[doc = "Selects best memory type automatically with preference for CPU (host) memory.\n\nWhen using this flag, if you want to map the allocation (using vmaMapMemory() or #VMA_ALLOCATION_CREATE_MAPPED_BIT),\nyou must pass one of the flags: #VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT or #VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT\nin VmaAllocationCreateInfo::flags.\n\nIt can be used only with functions that let the library know `VkBufferCreateInfo` or `VkImageCreateInfo`, e.g.\nvmaCreateBuffer(), vmaCreateImage(), vmaFindMemoryTypeIndexForBufferInfo(), vmaFindMemoryTypeIndexForImageInfo()\nand not with generic memory allocation functions."]
pub const VmaMemoryUsage_VMA_MEMORY_USAGE_AUTO_PREFER_HOST: VmaMemoryUsage = 9;
#[doc = "Selects best memory type automatically with preference for CPU (host) memory.\n\nWhen using this flag, if you want to map the allocation (using vmaMapMemory() or #VMA_ALLOCATION_CREATE_MAPPED_BIT),\nyou must pass one of the flags: #VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT or #VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT\nin VmaAllocationCreateInfo::flags.\n\nIt can be used only with functions that let the library know `VkBufferCreateInfo` or `VkImageCreateInfo`, e.g.\nvmaCreateBuffer(), vmaCreateImage(), vmaFindMemoryTypeIndexForBufferInfo(), vmaFindMemoryTypeIndexForImageInfo()\nand not with generic memory allocation functions."]
pub const VmaMemoryUsage_VMA_MEMORY_USAGE_MAX_ENUM: VmaMemoryUsage = 2147483647;
#[doc = " \\brief Intended usage of the allocated memory."]
pub type VmaMemoryUsage = ::std::os::raw::c_uint;
#[doc = " See #VmaAllocationCreateFlagBits."]
pub type VmaAllocationCreateFlags = VkFlags;
#[doc = " Flags to be passed as VmaPoolCreateInfo::flags. See #VmaPoolCreateFlagBits."]
pub type VmaPoolCreateFlags = VkFlags;
#[doc = " See #VmaDefragmentationFlagBits."]
pub type VmaDefragmentationFlags = VkFlags;
#[doc = " Buffer/image has been recreated at `dstTmpAllocation`, data has been copied, old buffer/image has been destroyed. `srcAllocation` should be changed to point to the new place. This is the default value set by vmaBeginDefragmentationPass()."]
pub const VmaDefragmentationMoveOperation_VMA_DEFRAGMENTATION_MOVE_OPERATION_COPY:
    VmaDefragmentationMoveOperation = 0;
#[doc = " Set this value if you cannot move the allocation. New place reserved at `dstTmpAllocation` will be freed. `srcAllocation` will remain unchanged."]
pub const VmaDefragmentationMoveOperation_VMA_DEFRAGMENTATION_MOVE_OPERATION_IGNORE:
    VmaDefragmentationMoveOperation = 1;
#[doc = " Set this value if you decide to abandon the allocation and you destroyed the buffer/image. New place reserved at `dstTmpAllocation` will be freed, along with `srcAllocation`, which will be destroyed."]
pub const VmaDefragmentationMoveOperation_VMA_DEFRAGMENTATION_MOVE_OPERATION_DESTROY:
    VmaDefragmentationMoveOperation = 2;
#[doc = " Operation performed on single defragmentation move. See structure #VmaDefragmentationMove."]
pub type VmaDefragmentationMoveOperation = ::std::os::raw::c_uint;
#[doc = " Flags to be passed as VmaVirtualBlockCreateInfo::flags. See #VmaVirtualBlockCreateFlagBits."]
pub type VmaVirtualBlockCreateFlags = VkFlags;
#[doc = " Flags to be passed as VmaVirtualAllocationCreateInfo::flags. See #VmaVirtualAllocationCreateFlagBits."]
pub type VmaVirtualAllocationCreateFlags = VkFlags;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VmaAllocator_T {
    _unused: [u8; 0],
}
pub type VmaAllocator = *mut VmaAllocator_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VmaPool_T {
    _unused: [u8; 0],
}
pub type VmaPool = *mut VmaPool_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VmaAllocation_T {
    _unused: [u8; 0],
}
pub type VmaAllocation = *mut VmaAllocation_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VmaDefragmentationContext_T {
    _unused: [u8; 0],
}
pub type VmaDefragmentationContext = *mut VmaDefragmentationContext_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VmaVirtualAllocation_T {
    _unused: [u8; 0],
}
pub type VmaVirtualAllocation = *mut VmaVirtualAllocation_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VmaVirtualBlock_T {
    _unused: [u8; 0],
}
pub type VmaVirtualBlock = *mut VmaVirtualBlock_T;
#[doc = " Callback function called after successful vkAllocateMemory."]
pub type PFN_vmaAllocateDeviceMemoryFunction = ::std::option::Option<
    unsafe extern "C" fn(
        allocator: VmaAllocator,
        memoryType: u32,
        memory: VkDeviceMemory,
        size: VkDeviceSize,
        pUserData: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " Callback function called before vkFreeMemory."]
pub type PFN_vmaFreeDeviceMemoryFunction = ::std::option::Option<
    unsafe extern "C" fn(
        allocator: VmaAllocator,
        memoryType: u32,
        memory: VkDeviceMemory,
        size: VkDeviceSize,
        pUserData: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " \\brief Set of callbacks that the library will call for `vkAllocateMemory` and `vkFreeMemory`.\n\nProvided for informative purpose, e.g. to gather statistics about number of\nallocations or total amount of memory allocated in Vulkan.\n\nUsed in VmaAllocatorCreateInfo::pDeviceMemoryCallbacks."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VmaDeviceMemoryCallbacks {
    #[doc = " Optional, can be null."]
    pub pfnAllocate: PFN_vmaAllocateDeviceMemoryFunction,
    #[doc = " Optional, can be null."]
    pub pfnFree: PFN_vmaFreeDeviceMemoryFunction,
    #[doc = " Optional, can be null."]
    pub pUserData: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_VmaDeviceMemoryCallbacks() {
    const UNINIT: ::std::mem::MaybeUninit<VmaDeviceMemoryCallbacks> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VmaDeviceMemoryCallbacks>(),
        24usize,
        concat!("Size of: ", stringify!(VmaDeviceMemoryCallbacks))
    );
    assert_eq!(
        ::std::mem::align_of::<VmaDeviceMemoryCallbacks>(),
        8usize,
        concat!("Alignment of ", stringify!(VmaDeviceMemoryCallbacks))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pfnAllocate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaDeviceMemoryCallbacks),
            "::",
            stringify!(pfnAllocate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pfnFree) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaDeviceMemoryCallbacks),
            "::",
            stringify!(pfnFree)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pUserData) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaDeviceMemoryCallbacks),
            "::",
            stringify!(pUserData)
        )
    );
}
#[doc = " \\brief Pointers to some Vulkan functions - a subset used by the library.\n\nUsed in VmaAllocatorCreateInfo::pVulkanFunctions."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VmaVulkanFunctions {
    #[doc = " Required when using VMA_DYNAMIC_VULKAN_FUNCTIONS."]
    pub vkGetInstanceProcAddr: PFN_vkGetInstanceProcAddr,
    #[doc = " Required when using VMA_DYNAMIC_VULKAN_FUNCTIONS."]
    pub vkGetDeviceProcAddr: PFN_vkGetDeviceProcAddr,
    pub vkGetPhysicalDeviceProperties: PFN_vkGetPhysicalDeviceProperties,
    pub vkGetPhysicalDeviceMemoryProperties: PFN_vkGetPhysicalDeviceMemoryProperties,
    pub vkAllocateMemory: PFN_vkAllocateMemory,
    pub vkFreeMemory: PFN_vkFreeMemory,
    pub vkMapMemory: PFN_vkMapMemory,
    pub vkUnmapMemory: PFN_vkUnmapMemory,
    pub vkFlushMappedMemoryRanges: PFN_vkFlushMappedMemoryRanges,
    pub vkInvalidateMappedMemoryRanges: PFN_vkInvalidateMappedMemoryRanges,
    pub vkBindBufferMemory: PFN_vkBindBufferMemory,
    pub vkBindImageMemory: PFN_vkBindImageMemory,
    pub vkGetBufferMemoryRequirements: PFN_vkGetBufferMemoryRequirements,
    pub vkGetImageMemoryRequirements: PFN_vkGetImageMemoryRequirements,
    pub vkCreateBuffer: PFN_vkCreateBuffer,
    pub vkDestroyBuffer: PFN_vkDestroyBuffer,
    pub vkCreateImage: PFN_vkCreateImage,
    pub vkDestroyImage: PFN_vkDestroyImage,
    pub vkCmdCopyBuffer: PFN_vkCmdCopyBuffer,
    #[doc = " Fetch \"vkGetBufferMemoryRequirements2\" on Vulkan >= 1.1, fetch \"vkGetBufferMemoryRequirements2KHR\" when using VK_KHR_dedicated_allocation extension."]
    pub vkGetBufferMemoryRequirements2KHR: PFN_vkGetBufferMemoryRequirements2KHR,
    #[doc = " Fetch \"vkGetImageMemoryRequirements2\" on Vulkan >= 1.1, fetch \"vkGetImageMemoryRequirements2KHR\" when using VK_KHR_dedicated_allocation extension."]
    pub vkGetImageMemoryRequirements2KHR: PFN_vkGetImageMemoryRequirements2KHR,
    #[doc = " Fetch \"vkBindBufferMemory2\" on Vulkan >= 1.1, fetch \"vkBindBufferMemory2KHR\" when using VK_KHR_bind_memory2 extension."]
    pub vkBindBufferMemory2KHR: PFN_vkBindBufferMemory2KHR,
    #[doc = " Fetch \"vkBindImageMemory2\" on Vulkan >= 1.1, fetch \"vkBindImageMemory2KHR\" when using VK_KHR_bind_memory2 extension."]
    pub vkBindImageMemory2KHR: PFN_vkBindImageMemory2KHR,
    #[doc = " Fetch from \"vkGetPhysicalDeviceMemoryProperties2\" on Vulkan >= 1.1, but you can also fetch it from \"vkGetPhysicalDeviceMemoryProperties2KHR\" if you enabled extension VK_KHR_get_physical_device_properties2."]
    pub vkGetPhysicalDeviceMemoryProperties2KHR: PFN_vkGetPhysicalDeviceMemoryProperties2KHR,
    #[doc = " Fetch from \"vkGetDeviceBufferMemoryRequirements\" on Vulkan >= 1.3, but you can also fetch it from \"vkGetDeviceBufferMemoryRequirementsKHR\" if you enabled extension VK_KHR_maintenance4."]
    pub vkGetDeviceBufferMemoryRequirements: PFN_vkGetDeviceBufferMemoryRequirementsKHR,
    #[doc = " Fetch from \"vkGetDeviceImageMemoryRequirements\" on Vulkan >= 1.3, but you can also fetch it from \"vkGetDeviceImageMemoryRequirementsKHR\" if you enabled extension VK_KHR_maintenance4."]
    pub vkGetDeviceImageMemoryRequirements: PFN_vkGetDeviceImageMemoryRequirementsKHR,
}
#[test]
fn bindgen_test_layout_VmaVulkanFunctions() {
    const UNINIT: ::std::mem::MaybeUninit<VmaVulkanFunctions> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VmaVulkanFunctions>(),
        208usize,
        concat!("Size of: ", stringify!(VmaVulkanFunctions))
    );
    assert_eq!(
        ::std::mem::align_of::<VmaVulkanFunctions>(),
        8usize,
        concat!("Alignment of ", stringify!(VmaVulkanFunctions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vkGetInstanceProcAddr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaVulkanFunctions),
            "::",
            stringify!(vkGetInstanceProcAddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vkGetDeviceProcAddr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaVulkanFunctions),
            "::",
            stringify!(vkGetDeviceProcAddr)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).vkGetPhysicalDeviceProperties) as usize - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaVulkanFunctions),
            "::",
            stringify!(vkGetPhysicalDeviceProperties)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).vkGetPhysicalDeviceMemoryProperties) as usize - ptr as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaVulkanFunctions),
            "::",
            stringify!(vkGetPhysicalDeviceMemoryProperties)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vkAllocateMemory) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaVulkanFunctions),
            "::",
            stringify!(vkAllocateMemory)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vkFreeMemory) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaVulkanFunctions),
            "::",
            stringify!(vkFreeMemory)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vkMapMemory) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaVulkanFunctions),
            "::",
            stringify!(vkMapMemory)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vkUnmapMemory) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaVulkanFunctions),
            "::",
            stringify!(vkUnmapMemory)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vkFlushMappedMemoryRanges) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaVulkanFunctions),
            "::",
            stringify!(vkFlushMappedMemoryRanges)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).vkInvalidateMappedMemoryRanges) as usize - ptr as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaVulkanFunctions),
            "::",
            stringify!(vkInvalidateMappedMemoryRanges)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vkBindBufferMemory) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaVulkanFunctions),
            "::",
            stringify!(vkBindBufferMemory)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vkBindImageMemory) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaVulkanFunctions),
            "::",
            stringify!(vkBindImageMemory)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).vkGetBufferMemoryRequirements) as usize - ptr as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaVulkanFunctions),
            "::",
            stringify!(vkGetBufferMemoryRequirements)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).vkGetImageMemoryRequirements) as usize - ptr as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaVulkanFunctions),
            "::",
            stringify!(vkGetImageMemoryRequirements)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vkCreateBuffer) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaVulkanFunctions),
            "::",
            stringify!(vkCreateBuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vkDestroyBuffer) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaVulkanFunctions),
            "::",
            stringify!(vkDestroyBuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vkCreateImage) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaVulkanFunctions),
            "::",
            stringify!(vkCreateImage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vkDestroyImage) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaVulkanFunctions),
            "::",
            stringify!(vkDestroyImage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vkCmdCopyBuffer) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaVulkanFunctions),
            "::",
            stringify!(vkCmdCopyBuffer)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).vkGetBufferMemoryRequirements2KHR) as usize - ptr as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaVulkanFunctions),
            "::",
            stringify!(vkGetBufferMemoryRequirements2KHR)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).vkGetImageMemoryRequirements2KHR) as usize - ptr as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaVulkanFunctions),
            "::",
            stringify!(vkGetImageMemoryRequirements2KHR)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vkBindBufferMemory2KHR) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaVulkanFunctions),
            "::",
            stringify!(vkBindBufferMemory2KHR)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vkBindImageMemory2KHR) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaVulkanFunctions),
            "::",
            stringify!(vkBindImageMemory2KHR)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).vkGetPhysicalDeviceMemoryProperties2KHR) as usize
                - ptr as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaVulkanFunctions),
            "::",
            stringify!(vkGetPhysicalDeviceMemoryProperties2KHR)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).vkGetDeviceBufferMemoryRequirements) as usize - ptr as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaVulkanFunctions),
            "::",
            stringify!(vkGetDeviceBufferMemoryRequirements)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).vkGetDeviceImageMemoryRequirements) as usize - ptr as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaVulkanFunctions),
            "::",
            stringify!(vkGetDeviceImageMemoryRequirements)
        )
    );
}
#[doc = " Description of a Allocator to be created."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VmaAllocatorCreateInfo {
    #[doc = " Flags for created allocator. Use #VmaAllocatorCreateFlagBits enum."]
    pub flags: VmaAllocatorCreateFlags,
    #[doc = " Vulkan physical device.\n** It must be valid throughout whole lifetime of created allocator. */"]
    pub physicalDevice: VkPhysicalDevice,
    #[doc = " Vulkan device.\n** It must be valid throughout whole lifetime of created allocator. */"]
    pub device: VkDevice,
    #[doc = " Preferred size of a single `VkDeviceMemory` block to be allocated from large heaps > 1 GiB. Optional.\n** Set to 0 to use default, which is currently 256 MiB. */"]
    pub preferredLargeHeapBlockSize: VkDeviceSize,
    #[doc = " Custom CPU memory allocation callbacks. Optional.\n** Optional, can be null. When specified, will also be used for all CPU-side memory allocations. */"]
    pub pAllocationCallbacks: *const VkAllocationCallbacks,
    #[doc = " Informative callbacks for `vkAllocateMemory`, `vkFreeMemory`. Optional.\n** Optional, can be null. */"]
    pub pDeviceMemoryCallbacks: *const VmaDeviceMemoryCallbacks,
    #[doc = " \\brief Either null or a pointer to an array of limits on maximum number of bytes that can be allocated out of particular Vulkan memory heap.\n\nIf not NULL, it must be a pointer to an array of\n`VkPhysicalDeviceMemoryProperties::memoryHeapCount` elements, defining limit on\nmaximum number of bytes that can be allocated out of particular Vulkan memory\nheap.\n\nAny of the elements may be equal to `VK_WHOLE_SIZE`, which means no limit on that\nheap. This is also the default in case of `pHeapSizeLimit` = NULL.\n\nIf there is a limit defined for a heap:\n\n- If user tries to allocate more memory from that heap using this allocator,\nthe allocation fails with `VK_ERROR_OUT_OF_DEVICE_MEMORY`.\n- If the limit is smaller than heap size reported in `VkMemoryHeap::size`, the\nvalue of this limit will be reported instead when using vmaGetMemoryProperties().\n\nWarning! Using this feature may not be equivalent to installing a GPU with\nsmaller amount of memory, because graphics driver doesn't necessary fail new\nallocations with `VK_ERROR_OUT_OF_DEVICE_MEMORY` result when memory capacity is\nexceeded. It may return success and just silently migrate some device memory\nblocks to system RAM. This driver behavior can also be controlled using\nVK_AMD_memory_overallocation_behavior extension."]
    pub pHeapSizeLimit: *const VkDeviceSize,
    #[doc = " \\brief Pointers to Vulkan functions. Can be null.\n\nFor details see [Pointers to Vulkan functions](@ref config_Vulkan_functions)."]
    pub pVulkanFunctions: *const VmaVulkanFunctions,
    #[doc = " \\brief Handle to Vulkan instance object.\n\nStarting from version 3.0.0 this member is no longer optional, it must be set!"]
    pub instance: VkInstance,
    #[doc = " \\brief Optional. Vulkan version that the application uses.\n\nIt must be a value in the format as created by macro `VK_MAKE_VERSION` or a constant like: `VK_API_VERSION_1_1`, `VK_API_VERSION_1_0`.\nThe patch version number specified is ignored. Only the major and minor versions are considered.\nOnly versions 1.0, 1.1, 1.2, 1.3 are supported by the current implementation.\nLeaving it initialized to zero is equivalent to `VK_API_VERSION_1_0`.\nIt must match the Vulkan version used by the application and supported on the selected physical device,\nso it must be no higher than `VkApplicationInfo::apiVersion` passed to `vkCreateInstance`\nand no higher than `VkPhysicalDeviceProperties::apiVersion` found on the physical device used."]
    pub vulkanApiVersion: u32,
    #[doc = " \\brief Either null or a pointer to an array of external memory handle types for each Vulkan memory type.\n\nIf not NULL, it must be a pointer to an array of `VkPhysicalDeviceMemoryProperties::memoryTypeCount`\nelements, defining external memory handle types of particular Vulkan memory type,\nto be passed using `VkExportMemoryAllocateInfoKHR`.\n\nAny of the elements may be equal to 0, which means not to use `VkExportMemoryAllocateInfoKHR` on this memory type.\nThis is also the default in case of `pTypeExternalMemoryHandleTypes` = NULL."]
    pub pTypeExternalMemoryHandleTypes: *const VkExternalMemoryHandleTypeFlagsKHR,
}
#[test]
fn bindgen_test_layout_VmaAllocatorCreateInfo() {
    const UNINIT: ::std::mem::MaybeUninit<VmaAllocatorCreateInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VmaAllocatorCreateInfo>(),
        88usize,
        concat!("Size of: ", stringify!(VmaAllocatorCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VmaAllocatorCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VmaAllocatorCreateInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaAllocatorCreateInfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).physicalDevice) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaAllocatorCreateInfo),
            "::",
            stringify!(physicalDevice)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).device) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaAllocatorCreateInfo),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).preferredLargeHeapBlockSize) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaAllocatorCreateInfo),
            "::",
            stringify!(preferredLargeHeapBlockSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pAllocationCallbacks) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaAllocatorCreateInfo),
            "::",
            stringify!(pAllocationCallbacks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pDeviceMemoryCallbacks) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaAllocatorCreateInfo),
            "::",
            stringify!(pDeviceMemoryCallbacks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pHeapSizeLimit) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaAllocatorCreateInfo),
            "::",
            stringify!(pHeapSizeLimit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pVulkanFunctions) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaAllocatorCreateInfo),
            "::",
            stringify!(pVulkanFunctions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).instance) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaAllocatorCreateInfo),
            "::",
            stringify!(instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vulkanApiVersion) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaAllocatorCreateInfo),
            "::",
            stringify!(vulkanApiVersion)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).pTypeExternalMemoryHandleTypes) as usize - ptr as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaAllocatorCreateInfo),
            "::",
            stringify!(pTypeExternalMemoryHandleTypes)
        )
    );
}
#[doc = " Information about existing #VmaAllocator object."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VmaAllocatorInfo {
    #[doc = " \\brief Handle to Vulkan instance object.\n\nThis is the same value as has been passed through VmaAllocatorCreateInfo::instance."]
    pub instance: VkInstance,
    #[doc = " \\brief Handle to Vulkan physical device object.\n\nThis is the same value as has been passed through VmaAllocatorCreateInfo::physicalDevice."]
    pub physicalDevice: VkPhysicalDevice,
    #[doc = " \\brief Handle to Vulkan device object.\n\nThis is the same value as has been passed through VmaAllocatorCreateInfo::device."]
    pub device: VkDevice,
}
#[test]
fn bindgen_test_layout_VmaAllocatorInfo() {
    const UNINIT: ::std::mem::MaybeUninit<VmaAllocatorInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VmaAllocatorInfo>(),
        24usize,
        concat!("Size of: ", stringify!(VmaAllocatorInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VmaAllocatorInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VmaAllocatorInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaAllocatorInfo),
            "::",
            stringify!(instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).physicalDevice) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaAllocatorInfo),
            "::",
            stringify!(physicalDevice)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).device) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaAllocatorInfo),
            "::",
            stringify!(device)
        )
    );
}
#[doc = " \\brief Calculated statistics of memory usage e.g. in a specific memory type, heap, custom pool, or total.\n\nThese are fast to calculate.\nSee functions: vmaGetHeapBudgets(), vmaGetPoolStatistics()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VmaStatistics {
    #[doc = " \\brief Number of `VkDeviceMemory` objects - Vulkan memory blocks allocated."]
    pub blockCount: u32,
    #[doc = " \\brief Number of #VmaAllocation objects allocated.\n\nDedicated allocations have their own blocks, so each one adds 1 to `allocationCount` as well as `blockCount`."]
    pub allocationCount: u32,
    #[doc = " \\brief Number of bytes allocated in `VkDeviceMemory` blocks.\n\n\\note To avoid confusion, please be aware that what Vulkan calls an \"allocation\" - a whole `VkDeviceMemory` object\n(e.g. as in `VkPhysicalDeviceLimits::maxMemoryAllocationCount`) is called a \"block\" in VMA, while VMA calls\n\"allocation\" a #VmaAllocation object that represents a memory region sub-allocated from such block, usually for a single buffer or image."]
    pub blockBytes: VkDeviceSize,
    #[doc = " \\brief Total number of bytes occupied by all #VmaAllocation objects.\n\nAlways less or equal than `blockBytes`.\nDifference `(blockBytes - allocationBytes)` is the amount of memory allocated from Vulkan\nbut unused by any #VmaAllocation."]
    pub allocationBytes: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VmaStatistics() {
    const UNINIT: ::std::mem::MaybeUninit<VmaStatistics> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VmaStatistics>(),
        24usize,
        concat!("Size of: ", stringify!(VmaStatistics))
    );
    assert_eq!(
        ::std::mem::align_of::<VmaStatistics>(),
        8usize,
        concat!("Alignment of ", stringify!(VmaStatistics))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blockCount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaStatistics),
            "::",
            stringify!(blockCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocationCount) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaStatistics),
            "::",
            stringify!(allocationCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blockBytes) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaStatistics),
            "::",
            stringify!(blockBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocationBytes) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaStatistics),
            "::",
            stringify!(allocationBytes)
        )
    );
}
#[doc = " \\brief More detailed statistics than #VmaStatistics.\n\nThese are slower to calculate. Use for debugging purposes.\nSee functions: vmaCalculateStatistics(), vmaCalculatePoolStatistics().\n\nPrevious version of the statistics API provided averages, but they have been removed\nbecause they can be easily calculated as:\n\n\\code\nVkDeviceSize allocationSizeAvg = detailedStats.statistics.allocationBytes / detailedStats.statistics.allocationCount;\nVkDeviceSize unusedBytes = detailedStats.statistics.blockBytes - detailedStats.statistics.allocationBytes;\nVkDeviceSize unusedRangeSizeAvg = unusedBytes / detailedStats.unusedRangeCount;\n\\endcode"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VmaDetailedStatistics {
    #[doc = " Basic statistics."]
    pub statistics: VmaStatistics,
    #[doc = " Number of free ranges of memory between allocations."]
    pub unusedRangeCount: u32,
    #[doc = " Smallest allocation size. `VK_WHOLE_SIZE` if there are 0 allocations."]
    pub allocationSizeMin: VkDeviceSize,
    #[doc = " Largest allocation size. 0 if there are 0 allocations."]
    pub allocationSizeMax: VkDeviceSize,
    #[doc = " Smallest empty range size. `VK_WHOLE_SIZE` if there are 0 empty ranges."]
    pub unusedRangeSizeMin: VkDeviceSize,
    #[doc = " Largest empty range size. 0 if there are 0 empty ranges."]
    pub unusedRangeSizeMax: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VmaDetailedStatistics() {
    const UNINIT: ::std::mem::MaybeUninit<VmaDetailedStatistics> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VmaDetailedStatistics>(),
        64usize,
        concat!("Size of: ", stringify!(VmaDetailedStatistics))
    );
    assert_eq!(
        ::std::mem::align_of::<VmaDetailedStatistics>(),
        8usize,
        concat!("Alignment of ", stringify!(VmaDetailedStatistics))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).statistics) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaDetailedStatistics),
            "::",
            stringify!(statistics)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unusedRangeCount) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaDetailedStatistics),
            "::",
            stringify!(unusedRangeCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocationSizeMin) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaDetailedStatistics),
            "::",
            stringify!(allocationSizeMin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocationSizeMax) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaDetailedStatistics),
            "::",
            stringify!(allocationSizeMax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unusedRangeSizeMin) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaDetailedStatistics),
            "::",
            stringify!(unusedRangeSizeMin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unusedRangeSizeMax) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaDetailedStatistics),
            "::",
            stringify!(unusedRangeSizeMax)
        )
    );
}
#[doc = " \\brief  General statistics from current state of the Allocator -\ntotal memory usage across all memory heaps and types.\n\nThese are slower to calculate. Use for debugging purposes.\nSee function vmaCalculateStatistics()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VmaTotalStatistics {
    pub memoryType: [VmaDetailedStatistics; 32usize],
    pub memoryHeap: [VmaDetailedStatistics; 16usize],
    pub total: VmaDetailedStatistics,
}
#[test]
fn bindgen_test_layout_VmaTotalStatistics() {
    const UNINIT: ::std::mem::MaybeUninit<VmaTotalStatistics> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VmaTotalStatistics>(),
        3136usize,
        concat!("Size of: ", stringify!(VmaTotalStatistics))
    );
    assert_eq!(
        ::std::mem::align_of::<VmaTotalStatistics>(),
        8usize,
        concat!("Alignment of ", stringify!(VmaTotalStatistics))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memoryType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaTotalStatistics),
            "::",
            stringify!(memoryType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memoryHeap) as usize - ptr as usize },
        2048usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaTotalStatistics),
            "::",
            stringify!(memoryHeap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).total) as usize - ptr as usize },
        3072usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaTotalStatistics),
            "::",
            stringify!(total)
        )
    );
}
#[doc = " \\brief Statistics of current memory usage and available budget for a specific memory heap.\n\nThese are fast to calculate.\nSee function vmaGetHeapBudgets()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VmaBudget {
    #[doc = " \\brief Statistics fetched from the library."]
    pub statistics: VmaStatistics,
    #[doc = " \\brief Estimated current memory usage of the program, in bytes.\n\nFetched from system using VK_EXT_memory_budget extension if enabled.\n\nIt might be different than `statistics.blockBytes` (usually higher) due to additional implicit objects\nalso occupying the memory, like swapchain, pipelines, descriptor heaps, command buffers, or\n`VkDeviceMemory` blocks allocated outside of this library, if any."]
    pub usage: VkDeviceSize,
    #[doc = " \\brief Estimated amount of memory available to the program, in bytes.\n\nFetched from system using VK_EXT_memory_budget extension if enabled.\n\nIt might be different (most probably smaller) than `VkMemoryHeap::size[heapIndex]` due to factors\nexternal to the program, decided by the operating system.\nDifference `budget - usage` is the amount of additional memory that can probably\nbe allocated without problems. Exceeding the budget may result in various problems."]
    pub budget: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VmaBudget() {
    const UNINIT: ::std::mem::MaybeUninit<VmaBudget> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VmaBudget>(),
        40usize,
        concat!("Size of: ", stringify!(VmaBudget))
    );
    assert_eq!(
        ::std::mem::align_of::<VmaBudget>(),
        8usize,
        concat!("Alignment of ", stringify!(VmaBudget))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).statistics) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaBudget),
            "::",
            stringify!(statistics)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).usage) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaBudget),
            "::",
            stringify!(usage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).budget) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaBudget),
            "::",
            stringify!(budget)
        )
    );
}
#[doc = " \\brief Parameters of new #VmaAllocation.\n\nTo be used with functions like vmaCreateBuffer(), vmaCreateImage(), and many others."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VmaAllocationCreateInfo {
    #[doc = " Use #VmaAllocationCreateFlagBits enum."]
    pub flags: VmaAllocationCreateFlags,
    #[doc = " \\brief Intended usage of memory.\n\nYou can leave #VMA_MEMORY_USAGE_UNKNOWN if you specify memory requirements in other way. \\n\nIf `pool` is not null, this member is ignored."]
    pub usage: VmaMemoryUsage,
    #[doc = " \\brief Flags that must be set in a Memory Type chosen for an allocation.\n\nLeave 0 if you specify memory requirements in other way. \\n\nIf `pool` is not null, this member is ignored."]
    pub requiredFlags: VkMemoryPropertyFlags,
    #[doc = " \\brief Flags that preferably should be set in a memory type chosen for an allocation.\n\nSet to 0 if no additional flags are preferred. \\n\nIf `pool` is not null, this member is ignored."]
    pub preferredFlags: VkMemoryPropertyFlags,
    #[doc = " \\brief Bitmask containing one bit set for every memory type acceptable for this allocation.\n\nValue 0 is equivalent to `UINT32_MAX` - it means any memory type is accepted if\nit meets other requirements specified by this structure, with no further\nrestrictions on memory type index. \\n\nIf `pool` is not null, this member is ignored."]
    pub memoryTypeBits: u32,
    #[doc = " \\brief Pool that this allocation should be created in.\n\nLeave `VK_NULL_HANDLE` to allocate from default pool. If not null, members:\n`usage`, `requiredFlags`, `preferredFlags`, `memoryTypeBits` are ignored."]
    pub pool: VmaPool,
    #[doc = " \\brief Custom general-purpose pointer that will be stored in #VmaAllocation, can be read as VmaAllocationInfo::pUserData and changed using vmaSetAllocationUserData().\n\nIf #VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT is used, it must be either\nnull or pointer to a null-terminated string. The string will be then copied to\ninternal buffer, so it doesn't need to be valid after allocation call."]
    pub pUserData: *mut ::std::os::raw::c_void,
    #[doc = " \\brief A floating-point value between 0 and 1, indicating the priority of the allocation relative to other memory allocations.\n\nIt is used only when #VMA_ALLOCATOR_CREATE_EXT_MEMORY_PRIORITY_BIT flag was used during creation of the #VmaAllocator object\nand this allocation ends up as dedicated or is explicitly forced as dedicated using #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.\nOtherwise, it has the priority of a memory block where it is placed and this variable is ignored."]
    pub priority: f32,
}
#[test]
fn bindgen_test_layout_VmaAllocationCreateInfo() {
    const UNINIT: ::std::mem::MaybeUninit<VmaAllocationCreateInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VmaAllocationCreateInfo>(),
        48usize,
        concat!("Size of: ", stringify!(VmaAllocationCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VmaAllocationCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VmaAllocationCreateInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaAllocationCreateInfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).usage) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaAllocationCreateInfo),
            "::",
            stringify!(usage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).requiredFlags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaAllocationCreateInfo),
            "::",
            stringify!(requiredFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).preferredFlags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaAllocationCreateInfo),
            "::",
            stringify!(preferredFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memoryTypeBits) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaAllocationCreateInfo),
            "::",
            stringify!(memoryTypeBits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pool) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaAllocationCreateInfo),
            "::",
            stringify!(pool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pUserData) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaAllocationCreateInfo),
            "::",
            stringify!(pUserData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priority) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaAllocationCreateInfo),
            "::",
            stringify!(priority)
        )
    );
}
#[doc = " Describes parameter of created #VmaPool."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VmaPoolCreateInfo {
    #[doc = " \\brief Vulkan memory type index to allocate this pool from."]
    pub memoryTypeIndex: u32,
    #[doc = " \\brief Use combination of #VmaPoolCreateFlagBits."]
    pub flags: VmaPoolCreateFlags,
    #[doc = " \\brief Size of a single `VkDeviceMemory` block to be allocated as part of this pool, in bytes. Optional.\n\nSpecify nonzero to set explicit, constant size of memory blocks used by this\npool.\n\nLeave 0 to use default and let the library manage block sizes automatically.\nSizes of particular blocks may vary.\nIn this case, the pool will also support dedicated allocations."]
    pub blockSize: VkDeviceSize,
    #[doc = " \\brief Minimum number of blocks to be always allocated in this pool, even if they stay empty.\n\nSet to 0 to have no preallocated blocks and allow the pool be completely empty."]
    pub minBlockCount: usize,
    #[doc = " \\brief Maximum number of blocks that can be allocated in this pool. Optional.\n\nSet to 0 to use default, which is `SIZE_MAX`, which means no limit.\n\nSet to same value as VmaPoolCreateInfo::minBlockCount to have fixed amount of memory allocated\nthroughout whole lifetime of this pool."]
    pub maxBlockCount: usize,
    #[doc = " \\brief A floating-point value between 0 and 1, indicating the priority of the allocations in this pool relative to other memory allocations.\n\nIt is used only when #VMA_ALLOCATOR_CREATE_EXT_MEMORY_PRIORITY_BIT flag was used during creation of the #VmaAllocator object.\nOtherwise, this variable is ignored."]
    pub priority: f32,
    #[doc = " \\brief Additional minimum alignment to be used for all allocations created from this pool. Can be 0.\n\nLeave 0 (default) not to impose any additional alignment. If not 0, it must be a power of two.\nIt can be useful in cases where alignment returned by Vulkan by functions like `vkGetBufferMemoryRequirements` is not enough,\ne.g. when doing interop with OpenGL."]
    pub minAllocationAlignment: VkDeviceSize,
    #[doc = " \\brief Additional `pNext` chain to be attached to `VkMemoryAllocateInfo` used for every allocation made by this pool. Optional.\n\nOptional, can be null. If not null, it must point to a `pNext` chain of structures that can be attached to `VkMemoryAllocateInfo`.\nIt can be useful for special needs such as adding `VkExportMemoryAllocateInfoKHR`.\nStructures pointed by this member must remain alive and unchanged for the whole lifetime of the custom pool.\n\nPlease note that some structures, e.g. `VkMemoryPriorityAllocateInfoEXT`, `VkMemoryDedicatedAllocateInfoKHR`,\ncan be attached automatically by this library when using other, more convenient of its features."]
    pub pMemoryAllocateNext: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_VmaPoolCreateInfo() {
    const UNINIT: ::std::mem::MaybeUninit<VmaPoolCreateInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VmaPoolCreateInfo>(),
        56usize,
        concat!("Size of: ", stringify!(VmaPoolCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VmaPoolCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VmaPoolCreateInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memoryTypeIndex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaPoolCreateInfo),
            "::",
            stringify!(memoryTypeIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaPoolCreateInfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blockSize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaPoolCreateInfo),
            "::",
            stringify!(blockSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minBlockCount) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaPoolCreateInfo),
            "::",
            stringify!(minBlockCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxBlockCount) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaPoolCreateInfo),
            "::",
            stringify!(maxBlockCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priority) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaPoolCreateInfo),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minAllocationAlignment) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaPoolCreateInfo),
            "::",
            stringify!(minAllocationAlignment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pMemoryAllocateNext) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaPoolCreateInfo),
            "::",
            stringify!(pMemoryAllocateNext)
        )
    );
}
#[doc = "Parameters of #VmaAllocation objects, that can be retrieved using function vmaGetAllocationInfo().\n\nThere is also an extended version of this structure that carries additional parameters: #VmaAllocationInfo2."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VmaAllocationInfo {
    #[doc = " \\brief Memory type index that this allocation was allocated from.\n\nIt never changes."]
    pub memoryType: u32,
    #[doc = " \\brief Handle to Vulkan memory object.\n\nSame memory object can be shared by multiple allocations.\n\nIt can change after the allocation is moved during \\ref defragmentation."]
    pub deviceMemory: VkDeviceMemory,
    #[doc = " \\brief Offset in `VkDeviceMemory` object to the beginning of this allocation, in bytes. `(deviceMemory, offset)` pair is unique to this allocation.\n\nYou usually don't need to use this offset. If you create a buffer or an image together with the allocation using e.g. function\nvmaCreateBuffer(), vmaCreateImage(), functions that operate on these resources refer to the beginning of the buffer or image,\nnot entire device memory block. Functions like vmaMapMemory(), vmaBindBufferMemory() also refer to the beginning of the allocation\nand apply this offset automatically.\n\nIt can change after the allocation is moved during \\ref defragmentation."]
    pub offset: VkDeviceSize,
    #[doc = " \\brief Size of this allocation, in bytes.\n\nIt never changes.\n\n\\note Allocation size returned in this variable may be greater than the size\nrequested for the resource e.g. as `VkBufferCreateInfo::size`. Whole size of the\nallocation is accessible for operations on memory e.g. using a pointer after\nmapping with vmaMapMemory(), but operations on the resource e.g. using\n`vkCmdCopyBuffer` must be limited to the size of the resource."]
    pub size: VkDeviceSize,
    #[doc = " \\brief Pointer to the beginning of this allocation as mapped data.\n\nIf the allocation hasn't been mapped using vmaMapMemory() and hasn't been\ncreated with #VMA_ALLOCATION_CREATE_MAPPED_BIT flag, this value is null.\n\nIt can change after call to vmaMapMemory(), vmaUnmapMemory().\nIt can also change after the allocation is moved during \\ref defragmentation."]
    pub pMappedData: *mut ::std::os::raw::c_void,
    #[doc = " \\brief Custom general-purpose pointer that was passed as VmaAllocationCreateInfo::pUserData or set using vmaSetAllocationUserData().\n\nIt can change after call to vmaSetAllocationUserData() for this allocation."]
    pub pUserData: *mut ::std::os::raw::c_void,
    #[doc = " \\brief Custom allocation name that was set with vmaSetAllocationName().\n\nIt can change after call to vmaSetAllocationName() for this allocation.\n\nAnother way to set custom name is to pass it in VmaAllocationCreateInfo::pUserData with\nadditional flag #VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT set [DEPRECATED]."]
    pub pName: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_VmaAllocationInfo() {
    const UNINIT: ::std::mem::MaybeUninit<VmaAllocationInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VmaAllocationInfo>(),
        56usize,
        concat!("Size of: ", stringify!(VmaAllocationInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VmaAllocationInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VmaAllocationInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memoryType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaAllocationInfo),
            "::",
            stringify!(memoryType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deviceMemory) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaAllocationInfo),
            "::",
            stringify!(deviceMemory)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaAllocationInfo),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaAllocationInfo),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pMappedData) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaAllocationInfo),
            "::",
            stringify!(pMappedData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pUserData) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaAllocationInfo),
            "::",
            stringify!(pUserData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pName) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaAllocationInfo),
            "::",
            stringify!(pName)
        )
    );
}
#[doc = " Extended parameters of a #VmaAllocation object that can be retrieved using function vmaGetAllocationInfo2()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VmaAllocationInfo2 {
    #[doc = " \\brief Basic parameters of the allocation.\n\nIf you need only these, you can use function vmaGetAllocationInfo() and structure #VmaAllocationInfo instead."]
    pub allocationInfo: VmaAllocationInfo,
    #[doc = " \\brief Size of the `VkDeviceMemory` block that the allocation belongs to.\n\nIn case of an allocation with dedicated memory, it will be equal to `allocationInfo.size`."]
    pub blockSize: VkDeviceSize,
    #[doc = " \\brief `VK_TRUE` if the allocation has dedicated memory, `VK_FALSE` if it was placed as part of a larger memory block.\n\nWhen `VK_TRUE`, it also means `VkMemoryDedicatedAllocateInfo` was used when creating the allocation\n(if VK_KHR_dedicated_allocation extension or Vulkan version >= 1.1 is enabled)."]
    pub dedicatedMemory: VkBool32,
}
#[test]
fn bindgen_test_layout_VmaAllocationInfo2() {
    const UNINIT: ::std::mem::MaybeUninit<VmaAllocationInfo2> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VmaAllocationInfo2>(),
        72usize,
        concat!("Size of: ", stringify!(VmaAllocationInfo2))
    );
    assert_eq!(
        ::std::mem::align_of::<VmaAllocationInfo2>(),
        8usize,
        concat!("Alignment of ", stringify!(VmaAllocationInfo2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocationInfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaAllocationInfo2),
            "::",
            stringify!(allocationInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blockSize) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaAllocationInfo2),
            "::",
            stringify!(blockSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dedicatedMemory) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaAllocationInfo2),
            "::",
            stringify!(dedicatedMemory)
        )
    );
}
#[doc = " Callback function called during vmaBeginDefragmentation() to check custom criterion about ending current defragmentation pass.\n\nShould return true if the defragmentation needs to stop current pass."]
pub type PFN_vmaCheckDefragmentationBreakFunction =
    ::std::option::Option<unsafe extern "C" fn(pUserData: *mut ::std::os::raw::c_void) -> VkBool32>;
#[doc = " \\brief Parameters for defragmentation.\n\nTo be used with function vmaBeginDefragmentation()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VmaDefragmentationInfo {
    #[doc = " \\brief Use combination of #VmaDefragmentationFlagBits."]
    pub flags: VmaDefragmentationFlags,
    #[doc = " \\brief Custom pool to be defragmented.\n\nIf null then default pools will undergo defragmentation process."]
    pub pool: VmaPool,
    #[doc = " \\brief Maximum numbers of bytes that can be copied during single pass, while moving allocations to different places.\n\n`0` means no limit."]
    pub maxBytesPerPass: VkDeviceSize,
    #[doc = " \\brief Maximum number of allocations that can be moved during single pass to a different place.\n\n`0` means no limit."]
    pub maxAllocationsPerPass: u32,
    #[doc = " \\brief Optional custom callback for stopping vmaBeginDefragmentation().\n\nHave to return true for breaking current defragmentation pass."]
    pub pfnBreakCallback: PFN_vmaCheckDefragmentationBreakFunction,
    #[doc = " \\brief Optional data to pass to custom callback for stopping pass of defragmentation."]
    pub pBreakCallbackUserData: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_VmaDefragmentationInfo() {
    const UNINIT: ::std::mem::MaybeUninit<VmaDefragmentationInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VmaDefragmentationInfo>(),
        48usize,
        concat!("Size of: ", stringify!(VmaDefragmentationInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VmaDefragmentationInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VmaDefragmentationInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaDefragmentationInfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pool) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaDefragmentationInfo),
            "::",
            stringify!(pool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxBytesPerPass) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaDefragmentationInfo),
            "::",
            stringify!(maxBytesPerPass)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxAllocationsPerPass) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaDefragmentationInfo),
            "::",
            stringify!(maxAllocationsPerPass)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pfnBreakCallback) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaDefragmentationInfo),
            "::",
            stringify!(pfnBreakCallback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pBreakCallbackUserData) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaDefragmentationInfo),
            "::",
            stringify!(pBreakCallbackUserData)
        )
    );
}
#[doc = " Single move of an allocation to be done for defragmentation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VmaDefragmentationMove {
    #[doc = " Operation to be performed on the allocation by vmaEndDefragmentationPass(). Default value is #VMA_DEFRAGMENTATION_MOVE_OPERATION_COPY. You can modify it."]
    pub operation: VmaDefragmentationMoveOperation,
    #[doc = " Allocation that should be moved."]
    pub srcAllocation: VmaAllocation,
    #[doc = " \\brief Temporary allocation pointing to destination memory that will replace `srcAllocation`.\n\n\\warning Do not store this allocation in your data structures! It exists only temporarily, for the duration of the defragmentation pass,\nto be used for binding new buffer/image to the destination memory using e.g. vmaBindBufferMemory().\nvmaEndDefragmentationPass() will destroy it and make `srcAllocation` point to this memory."]
    pub dstTmpAllocation: VmaAllocation,
}
#[test]
fn bindgen_test_layout_VmaDefragmentationMove() {
    const UNINIT: ::std::mem::MaybeUninit<VmaDefragmentationMove> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VmaDefragmentationMove>(),
        24usize,
        concat!("Size of: ", stringify!(VmaDefragmentationMove))
    );
    assert_eq!(
        ::std::mem::align_of::<VmaDefragmentationMove>(),
        8usize,
        concat!("Alignment of ", stringify!(VmaDefragmentationMove))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).operation) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaDefragmentationMove),
            "::",
            stringify!(operation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srcAllocation) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaDefragmentationMove),
            "::",
            stringify!(srcAllocation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dstTmpAllocation) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaDefragmentationMove),
            "::",
            stringify!(dstTmpAllocation)
        )
    );
}
#[doc = " \\brief Parameters for incremental defragmentation steps.\n\nTo be used with function vmaBeginDefragmentationPass()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VmaDefragmentationPassMoveInfo {
    #[doc = " Number of elements in the `pMoves` array."]
    pub moveCount: u32,
    #[doc = " \\brief Array of moves to be performed by the user in the current defragmentation pass.\n\nPointer to an array of `moveCount` elements, owned by VMA, created in vmaBeginDefragmentationPass(), destroyed in vmaEndDefragmentationPass().\n\nFor each element, you should:\n\n1. Create a new buffer/image in the place pointed by VmaDefragmentationMove::dstMemory + VmaDefragmentationMove::dstOffset.\n2. Copy data from the VmaDefragmentationMove::srcAllocation e.g. using `vkCmdCopyBuffer`, `vkCmdCopyImage`.\n3. Make sure these commands finished executing on the GPU.\n4. Destroy the old buffer/image.\n\nOnly then you can finish defragmentation pass by calling vmaEndDefragmentationPass().\nAfter this call, the allocation will point to the new place in memory.\n\nAlternatively, if you cannot move specific allocation, you can set VmaDefragmentationMove::operation to #VMA_DEFRAGMENTATION_MOVE_OPERATION_IGNORE.\n\nAlternatively, if you decide you want to completely remove the allocation:\n\n1. Destroy its buffer/image.\n2. Set VmaDefragmentationMove::operation to #VMA_DEFRAGMENTATION_MOVE_OPERATION_DESTROY.\n\nThen, after vmaEndDefragmentationPass() the allocation will be freed."]
    pub pMoves: *mut VmaDefragmentationMove,
}
#[test]
fn bindgen_test_layout_VmaDefragmentationPassMoveInfo() {
    const UNINIT: ::std::mem::MaybeUninit<VmaDefragmentationPassMoveInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VmaDefragmentationPassMoveInfo>(),
        16usize,
        concat!("Size of: ", stringify!(VmaDefragmentationPassMoveInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VmaDefragmentationPassMoveInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VmaDefragmentationPassMoveInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).moveCount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaDefragmentationPassMoveInfo),
            "::",
            stringify!(moveCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pMoves) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaDefragmentationPassMoveInfo),
            "::",
            stringify!(pMoves)
        )
    );
}
#[doc = " Statistics returned for defragmentation process in function vmaEndDefragmentation()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VmaDefragmentationStats {
    #[doc = " Total number of bytes that have been copied while moving allocations to different places."]
    pub bytesMoved: VkDeviceSize,
    #[doc = " Total number of bytes that have been released to the system by freeing empty `VkDeviceMemory` objects."]
    pub bytesFreed: VkDeviceSize,
    #[doc = " Number of allocations that have been moved to different places."]
    pub allocationsMoved: u32,
    #[doc = " Number of empty `VkDeviceMemory` objects that have been released to the system."]
    pub deviceMemoryBlocksFreed: u32,
}
#[test]
fn bindgen_test_layout_VmaDefragmentationStats() {
    const UNINIT: ::std::mem::MaybeUninit<VmaDefragmentationStats> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VmaDefragmentationStats>(),
        24usize,
        concat!("Size of: ", stringify!(VmaDefragmentationStats))
    );
    assert_eq!(
        ::std::mem::align_of::<VmaDefragmentationStats>(),
        8usize,
        concat!("Alignment of ", stringify!(VmaDefragmentationStats))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytesMoved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaDefragmentationStats),
            "::",
            stringify!(bytesMoved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytesFreed) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaDefragmentationStats),
            "::",
            stringify!(bytesFreed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocationsMoved) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaDefragmentationStats),
            "::",
            stringify!(allocationsMoved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deviceMemoryBlocksFreed) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaDefragmentationStats),
            "::",
            stringify!(deviceMemoryBlocksFreed)
        )
    );
}
#[doc = " Parameters of created #VmaVirtualBlock object to be passed to vmaCreateVirtualBlock()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VmaVirtualBlockCreateInfo {
    #[doc = " \\brief Total size of the virtual block.\n\nSizes can be expressed in bytes or any units you want as long as you are consistent in using them.\nFor example, if you allocate from some array of structures, 1 can mean single instance of entire structure."]
    pub size: VkDeviceSize,
    #[doc = " \\brief Use combination of #VmaVirtualBlockCreateFlagBits."]
    pub flags: VmaVirtualBlockCreateFlags,
    #[doc = " \\brief Custom CPU memory allocation callbacks. Optional.\n\nOptional, can be null. When specified, they will be used for all CPU-side memory allocations."]
    pub pAllocationCallbacks: *const VkAllocationCallbacks,
}
#[test]
fn bindgen_test_layout_VmaVirtualBlockCreateInfo() {
    const UNINIT: ::std::mem::MaybeUninit<VmaVirtualBlockCreateInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VmaVirtualBlockCreateInfo>(),
        24usize,
        concat!("Size of: ", stringify!(VmaVirtualBlockCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VmaVirtualBlockCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VmaVirtualBlockCreateInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaVirtualBlockCreateInfo),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaVirtualBlockCreateInfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pAllocationCallbacks) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaVirtualBlockCreateInfo),
            "::",
            stringify!(pAllocationCallbacks)
        )
    );
}
#[doc = " Parameters of created virtual allocation to be passed to vmaVirtualAllocate()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VmaVirtualAllocationCreateInfo {
    #[doc = " \\brief Size of the allocation.\n\nCannot be zero."]
    pub size: VkDeviceSize,
    #[doc = " \\brief Required alignment of the allocation. Optional.\n\nMust be power of two. Special value 0 has the same meaning as 1 - means no special alignment is required, so allocation can start at any offset."]
    pub alignment: VkDeviceSize,
    #[doc = " \\brief Use combination of #VmaVirtualAllocationCreateFlagBits."]
    pub flags: VmaVirtualAllocationCreateFlags,
    #[doc = " \\brief Custom pointer to be associated with the allocation. Optional.\n\nIt can be any value and can be used for user-defined purposes. It can be fetched or changed later."]
    pub pUserData: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_VmaVirtualAllocationCreateInfo() {
    const UNINIT: ::std::mem::MaybeUninit<VmaVirtualAllocationCreateInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VmaVirtualAllocationCreateInfo>(),
        32usize,
        concat!("Size of: ", stringify!(VmaVirtualAllocationCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VmaVirtualAllocationCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VmaVirtualAllocationCreateInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaVirtualAllocationCreateInfo),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alignment) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaVirtualAllocationCreateInfo),
            "::",
            stringify!(alignment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaVirtualAllocationCreateInfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pUserData) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaVirtualAllocationCreateInfo),
            "::",
            stringify!(pUserData)
        )
    );
}
#[doc = " Parameters of an existing virtual allocation, returned by vmaGetVirtualAllocationInfo()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VmaVirtualAllocationInfo {
    #[doc = " \\brief Offset of the allocation.\n\nOffset at which the allocation was made."]
    pub offset: VkDeviceSize,
    #[doc = " \\brief Size of the allocation.\n\nSame value as passed in VmaVirtualAllocationCreateInfo::size."]
    pub size: VkDeviceSize,
    #[doc = " \\brief Custom pointer associated with the allocation.\n\nSame value as passed in VmaVirtualAllocationCreateInfo::pUserData or to vmaSetVirtualAllocationUserData()."]
    pub pUserData: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_VmaVirtualAllocationInfo() {
    const UNINIT: ::std::mem::MaybeUninit<VmaVirtualAllocationInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VmaVirtualAllocationInfo>(),
        24usize,
        concat!("Size of: ", stringify!(VmaVirtualAllocationInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VmaVirtualAllocationInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VmaVirtualAllocationInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaVirtualAllocationInfo),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaVirtualAllocationInfo),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pUserData) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VmaVirtualAllocationInfo),
            "::",
            stringify!(pUserData)
        )
    );
}
extern "C" {
    #[doc = " Creates #VmaAllocator object."]
    pub fn vmaCreateAllocator(
        pCreateInfo: *const VmaAllocatorCreateInfo,
        pAllocator: *mut VmaAllocator,
    ) -> VkResult;
}
extern "C" {
    #[doc = " Destroys allocator object."]
    pub fn vmaDestroyAllocator(allocator: VmaAllocator);
}
extern "C" {
    #[doc = " \\brief Returns information about existing #VmaAllocator object - handle to Vulkan device etc.\n\nIt might be useful if you want to keep just the #VmaAllocator handle and fetch other required handles to\n`VkPhysicalDevice`, `VkDevice` etc. every time using this function."]
    pub fn vmaGetAllocatorInfo(allocator: VmaAllocator, pAllocatorInfo: *mut VmaAllocatorInfo);
}
extern "C" {
    #[doc = "PhysicalDeviceProperties are fetched from physicalDevice by the allocator.\nYou can access it here, without fetching it again on your own."]
    pub fn vmaGetPhysicalDeviceProperties(
        allocator: VmaAllocator,
        ppPhysicalDeviceProperties: *mut *const VkPhysicalDeviceProperties,
    );
}
extern "C" {
    #[doc = "PhysicalDeviceMemoryProperties are fetched from physicalDevice by the allocator.\nYou can access it here, without fetching it again on your own."]
    pub fn vmaGetMemoryProperties(
        allocator: VmaAllocator,
        ppPhysicalDeviceMemoryProperties: *mut *const VkPhysicalDeviceMemoryProperties,
    );
}
extern "C" {
    #[doc = "\\brief Given Memory Type Index, returns Property Flags of this memory type.\n\nThis is just a convenience function. Same information can be obtained using\nvmaGetMemoryProperties()."]
    pub fn vmaGetMemoryTypeProperties(
        allocator: VmaAllocator,
        memoryTypeIndex: u32,
        pFlags: *mut VkMemoryPropertyFlags,
    );
}
extern "C" {
    #[doc = " \\brief Sets index of the current frame."]
    pub fn vmaSetCurrentFrameIndex(allocator: VmaAllocator, frameIndex: u32);
}
extern "C" {
    #[doc = " \\brief Retrieves statistics from current state of the Allocator.\n\nThis function is called \"calculate\" not \"get\" because it has to traverse all\ninternal data structures, so it may be quite slow. Use it for debugging purposes.\nFor faster but more brief statistics suitable to be called every frame or every allocation,\nuse vmaGetHeapBudgets().\n\nNote that when using allocator from multiple threads, returned information may immediately\nbecome outdated."]
    pub fn vmaCalculateStatistics(allocator: VmaAllocator, pStats: *mut VmaTotalStatistics);
}
extern "C" {
    #[doc = " \\brief Retrieves information about current memory usage and budget for all memory heaps.\n\n\\param allocator\n\\param[out] pBudgets Must point to array with number of elements at least equal to number of memory heaps in physical device used.\n\nThis function is called \"get\" not \"calculate\" because it is very fast, suitable to be called\nevery frame or every allocation. For more detailed statistics use vmaCalculateStatistics().\n\nNote that when using allocator from multiple threads, returned information may immediately\nbecome outdated."]
    pub fn vmaGetHeapBudgets(allocator: VmaAllocator, pBudgets: *mut VmaBudget);
}
extern "C" {
    #[doc = "\\brief Helps to find memoryTypeIndex, given memoryTypeBits and VmaAllocationCreateInfo.\n\nThis algorithm tries to find a memory type that:\n\n- Is allowed by memoryTypeBits.\n- Contains all the flags from pAllocationCreateInfo->requiredFlags.\n- Matches intended usage.\n- Has as many flags from pAllocationCreateInfo->preferredFlags as possible.\n\n\\return Returns VK_ERROR_FEATURE_NOT_PRESENT if not found. Receiving such result\nfrom this function or any other allocating function probably means that your\ndevice doesn't support any memory type with requested features for the specific\ntype of resource you want to use it for. Please check parameters of your\nresource, like image layout (OPTIMAL versus LINEAR) or mip level count."]
    pub fn vmaFindMemoryTypeIndex(
        allocator: VmaAllocator,
        memoryTypeBits: u32,
        pAllocationCreateInfo: *const VmaAllocationCreateInfo,
        pMemoryTypeIndex: *mut u32,
    ) -> VkResult;
}
extern "C" {
    #[doc = "\\brief Helps to find memoryTypeIndex, given VkBufferCreateInfo and VmaAllocationCreateInfo.\n\nIt can be useful e.g. to determine value to be used as VmaPoolCreateInfo::memoryTypeIndex.\nIt internally creates a temporary, dummy buffer that never has memory bound."]
    pub fn vmaFindMemoryTypeIndexForBufferInfo(
        allocator: VmaAllocator,
        pBufferCreateInfo: *const VkBufferCreateInfo,
        pAllocationCreateInfo: *const VmaAllocationCreateInfo,
        pMemoryTypeIndex: *mut u32,
    ) -> VkResult;
}
extern "C" {
    #[doc = "\\brief Helps to find memoryTypeIndex, given VkImageCreateInfo and VmaAllocationCreateInfo.\n\nIt can be useful e.g. to determine value to be used as VmaPoolCreateInfo::memoryTypeIndex.\nIt internally creates a temporary, dummy image that never has memory bound."]
    pub fn vmaFindMemoryTypeIndexForImageInfo(
        allocator: VmaAllocator,
        pImageCreateInfo: *const VkImageCreateInfo,
        pAllocationCreateInfo: *const VmaAllocationCreateInfo,
        pMemoryTypeIndex: *mut u32,
    ) -> VkResult;
}
extern "C" {
    #[doc = " \\brief Allocates Vulkan device memory and creates #VmaPool object.\n\n\\param allocator Allocator object.\n\\param pCreateInfo Parameters of pool to create.\n\\param[out] pPool Handle to created pool."]
    pub fn vmaCreatePool(
        allocator: VmaAllocator,
        pCreateInfo: *const VmaPoolCreateInfo,
        pPool: *mut VmaPool,
    ) -> VkResult;
}
extern "C" {
    #[doc = " \\brief Destroys #VmaPool object and frees Vulkan device memory."]
    pub fn vmaDestroyPool(allocator: VmaAllocator, pool: VmaPool);
}
extern "C" {
    #[doc = " \\brief Retrieves statistics of existing #VmaPool object.\n\n\\param allocator Allocator object.\n\\param pool Pool object.\n\\param[out] pPoolStats Statistics of specified pool."]
    pub fn vmaGetPoolStatistics(
        allocator: VmaAllocator,
        pool: VmaPool,
        pPoolStats: *mut VmaStatistics,
    );
}
extern "C" {
    #[doc = " \\brief Retrieves detailed statistics of existing #VmaPool object.\n\n\\param allocator Allocator object.\n\\param pool Pool object.\n\\param[out] pPoolStats Statistics of specified pool."]
    pub fn vmaCalculatePoolStatistics(
        allocator: VmaAllocator,
        pool: VmaPool,
        pPoolStats: *mut VmaDetailedStatistics,
    );
}
extern "C" {
    #[doc = " \\brief Checks magic number in margins around all allocations in given memory pool in search for corruptions.\n\nCorruption detection is enabled only when `VMA_DEBUG_DETECT_CORRUPTION` macro is defined to nonzero,\n`VMA_DEBUG_MARGIN` is defined to nonzero and the pool is created in memory type that is\n`HOST_VISIBLE` and `HOST_COHERENT`. For more information, see [Corruption detection](@ref debugging_memory_usage_corruption_detection).\n\nPossible return values:\n\n- `VK_ERROR_FEATURE_NOT_PRESENT` - corruption detection is not enabled for specified pool.\n- `VK_SUCCESS` - corruption detection has been performed and succeeded.\n- `VK_ERROR_UNKNOWN` - corruption detection has been performed and found memory corruptions around one of the allocations.\n`VMA_ASSERT` is also fired in that case.\n- Other value: Error returned by Vulkan, e.g. memory mapping failure."]
    pub fn vmaCheckPoolCorruption(allocator: VmaAllocator, pool: VmaPool) -> VkResult;
}
extern "C" {
    #[doc = " \\brief Retrieves name of a custom pool.\n\nAfter the call `ppName` is either null or points to an internally-owned null-terminated string\ncontaining name of the pool that was previously set. The pointer becomes invalid when the pool is\ndestroyed or its name is changed using vmaSetPoolName()."]
    pub fn vmaGetPoolName(
        allocator: VmaAllocator,
        pool: VmaPool,
        ppName: *mut *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " \\brief Sets name of a custom pool.\n\n`pName` can be either null or pointer to a null-terminated string with new name for the pool.\nFunction makes internal copy of the string, so it can be changed or freed immediately after this call."]
    pub fn vmaSetPoolName(
        allocator: VmaAllocator,
        pool: VmaPool,
        pName: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " \\brief General purpose memory allocation.\n\n\\param allocator\n\\param pVkMemoryRequirements\n\\param pCreateInfo\n\\param[out] pAllocation Handle to allocated memory.\n\\param[out] pAllocationInfo Optional. Information about allocated memory. It can be later fetched using function vmaGetAllocationInfo().\n\nYou should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().\n\nIt is recommended to use vmaAllocateMemoryForBuffer(), vmaAllocateMemoryForImage(),\nvmaCreateBuffer(), vmaCreateImage() instead whenever possible."]
    pub fn vmaAllocateMemory(
        allocator: VmaAllocator,
        pVkMemoryRequirements: *const VkMemoryRequirements,
        pCreateInfo: *const VmaAllocationCreateInfo,
        pAllocation: *mut VmaAllocation,
        pAllocationInfo: *mut VmaAllocationInfo,
    ) -> VkResult;
}
extern "C" {
    #[doc = " \\brief General purpose memory allocation for multiple allocation objects at once.\n\n\\param allocator Allocator object.\n\\param pVkMemoryRequirements Memory requirements for each allocation.\n\\param pCreateInfo Creation parameters for each allocation.\n\\param allocationCount Number of allocations to make.\n\\param[out] pAllocations Pointer to array that will be filled with handles to created allocations.\n\\param[out] pAllocationInfo Optional. Pointer to array that will be filled with parameters of created allocations.\n\nYou should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().\n\nWord \"pages\" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.\nIt is just a general purpose allocation function able to make multiple allocations at once.\nIt may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.\n\nAll allocations are made using same parameters. All of them are created out of the same memory pool and type.\nIf any allocation fails, all allocations already made within this function call are also freed, so that when\nreturned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`."]
    pub fn vmaAllocateMemoryPages(
        allocator: VmaAllocator,
        pVkMemoryRequirements: *const VkMemoryRequirements,
        pCreateInfo: *const VmaAllocationCreateInfo,
        allocationCount: usize,
        pAllocations: *mut VmaAllocation,
        pAllocationInfo: *mut VmaAllocationInfo,
    ) -> VkResult;
}
extern "C" {
    #[doc = " \\brief Allocates memory suitable for given `VkBuffer`.\n\n\\param allocator\n\\param buffer\n\\param pCreateInfo\n\\param[out] pAllocation Handle to allocated memory.\n\\param[out] pAllocationInfo Optional. Information about allocated memory. It can be later fetched using function vmaGetAllocationInfo().\n\nIt only creates #VmaAllocation. To bind the memory to the buffer, use vmaBindBufferMemory().\n\nThis is a special-purpose function. In most cases you should use vmaCreateBuffer().\n\nYou must free the allocation using vmaFreeMemory() when no longer needed."]
    pub fn vmaAllocateMemoryForBuffer(
        allocator: VmaAllocator,
        buffer: VkBuffer,
        pCreateInfo: *const VmaAllocationCreateInfo,
        pAllocation: *mut VmaAllocation,
        pAllocationInfo: *mut VmaAllocationInfo,
    ) -> VkResult;
}
extern "C" {
    #[doc = " \\brief Allocates memory suitable for given `VkImage`.\n\n\\param allocator\n\\param image\n\\param pCreateInfo\n\\param[out] pAllocation Handle to allocated memory.\n\\param[out] pAllocationInfo Optional. Information about allocated memory. It can be later fetched using function vmaGetAllocationInfo().\n\nIt only creates #VmaAllocation. To bind the memory to the buffer, use vmaBindImageMemory().\n\nThis is a special-purpose function. In most cases you should use vmaCreateImage().\n\nYou must free the allocation using vmaFreeMemory() when no longer needed."]
    pub fn vmaAllocateMemoryForImage(
        allocator: VmaAllocator,
        image: VkImage,
        pCreateInfo: *const VmaAllocationCreateInfo,
        pAllocation: *mut VmaAllocation,
        pAllocationInfo: *mut VmaAllocationInfo,
    ) -> VkResult;
}
extern "C" {
    #[doc = " \\brief Frees memory previously allocated using vmaAllocateMemory(), vmaAllocateMemoryForBuffer(), or vmaAllocateMemoryForImage().\n\nPassing `VK_NULL_HANDLE` as `allocation` is valid. Such function call is just skipped."]
    pub fn vmaFreeMemory(allocator: VmaAllocator, allocation: VmaAllocation);
}
extern "C" {
    #[doc = " \\brief Frees memory and destroys multiple allocations.\n\nWord \"pages\" is just a suggestion to use this function to free pieces of memory used for sparse binding.\nIt is just a general purpose function to free memory and destroy allocations made using e.g. vmaAllocateMemory(),\nvmaAllocateMemoryPages() and other functions.\nIt may be internally optimized to be more efficient than calling vmaFreeMemory() `allocationCount` times.\n\nAllocations in `pAllocations` array can come from any memory pools and types.\nPassing `VK_NULL_HANDLE` as elements of `pAllocations` array is valid. Such entries are just skipped."]
    pub fn vmaFreeMemoryPages(
        allocator: VmaAllocator,
        allocationCount: usize,
        pAllocations: *const *mut VmaAllocation_T,
    );
}
extern "C" {
    #[doc = " \\brief Returns current information about specified allocation.\n\nCurrent parameters of given allocation are returned in `pAllocationInfo`.\n\nAlthough this function doesn't lock any mutex, so it should be quite efficient,\nyou should avoid calling it too often.\nYou can retrieve same VmaAllocationInfo structure while creating your resource, from function\nvmaCreateBuffer(), vmaCreateImage(). You can remember it if you are sure parameters don't change\n(e.g. due to defragmentation).\n\nThere is also a new function vmaGetAllocationInfo2() that offers extended information\nabout the allocation, returned using new structure #VmaAllocationInfo2."]
    pub fn vmaGetAllocationInfo(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        pAllocationInfo: *mut VmaAllocationInfo,
    );
}
extern "C" {
    #[doc = " \\brief Returns extended information about specified allocation.\n\nCurrent parameters of given allocation are returned in `pAllocationInfo`.\nExtended parameters in structure #VmaAllocationInfo2 include memory block size\nand a flag telling whether the allocation has dedicated memory.\nIt can be useful e.g. for interop with OpenGL."]
    pub fn vmaGetAllocationInfo2(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        pAllocationInfo: *mut VmaAllocationInfo2,
    );
}
extern "C" {
    #[doc = " \\brief Sets pUserData in given allocation to new value.\n\nThe value of pointer `pUserData` is copied to allocation's `pUserData`.\nIt is opaque, so you can use it however you want - e.g.\nas a pointer, ordinal number or some handle to you own data."]
    pub fn vmaSetAllocationUserData(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        pUserData: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " \\brief Sets pName in given allocation to new value.\n\n`pName` must be either null, or pointer to a null-terminated string. The function\nmakes local copy of the string and sets it as allocation's `pName`. String\npassed as pName doesn't need to be valid for whole lifetime of the allocation -\nyou can free it after this call. String previously pointed by allocation's\n`pName` is freed from memory."]
    pub fn vmaSetAllocationName(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        pName: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = "\\brief Given an allocation, returns Property Flags of its memory type.\n\nThis is just a convenience function. Same information can be obtained using\nvmaGetAllocationInfo() + vmaGetMemoryProperties()."]
    pub fn vmaGetAllocationMemoryProperties(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        pFlags: *mut VkMemoryPropertyFlags,
    );
}
extern "C" {
    #[doc = " \\brief Maps memory represented by given allocation and returns pointer to it.\n\nMaps memory represented by given allocation to make it accessible to CPU code.\nWhen succeeded, `*ppData` contains pointer to first byte of this memory.\n\n\\warning\nIf the allocation is part of a bigger `VkDeviceMemory` block, returned pointer is\ncorrectly offsetted to the beginning of region assigned to this particular allocation.\nUnlike the result of `vkMapMemory`, it points to the allocation, not to the beginning of the whole block.\nYou should not add VmaAllocationInfo::offset to it!\n\nMapping is internally reference-counted and synchronized, so despite raw Vulkan\nfunction `vkMapMemory()` cannot be used to map same block of `VkDeviceMemory`\nmultiple times simultaneously, it is safe to call this function on allocations\nassigned to the same memory block. Actual Vulkan memory will be mapped on first\nmapping and unmapped on last unmapping.\n\nIf the function succeeded, you must call vmaUnmapMemory() to unmap the\nallocation when mapping is no longer needed or before freeing the allocation, at\nthe latest.\n\nIt also safe to call this function multiple times on the same allocation. You\nmust call vmaUnmapMemory() same number of times as you called vmaMapMemory().\n\nIt is also safe to call this function on allocation created with\n#VMA_ALLOCATION_CREATE_MAPPED_BIT flag. Its memory stays mapped all the time.\nYou must still call vmaUnmapMemory() same number of times as you called\nvmaMapMemory(). You must not call vmaUnmapMemory() additional time to free the\n\"0-th\" mapping made automatically due to #VMA_ALLOCATION_CREATE_MAPPED_BIT flag.\n\nThis function fails when used on allocation made in memory type that is not\n`HOST_VISIBLE`.\n\nThis function doesn't automatically flush or invalidate caches.\nIf the allocation is made from a memory types that is not `HOST_COHERENT`,\nyou also need to use vmaInvalidateAllocation() / vmaFlushAllocation(), as required by Vulkan specification."]
    pub fn vmaMapMemory(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        ppData: *mut *mut ::std::os::raw::c_void,
    ) -> VkResult;
}
extern "C" {
    #[doc = " \\brief Unmaps memory represented by given allocation, mapped previously using vmaMapMemory().\n\nFor details, see description of vmaMapMemory().\n\nThis function doesn't automatically flush or invalidate caches.\nIf the allocation is made from a memory types that is not `HOST_COHERENT`,\nyou also need to use vmaInvalidateAllocation() / vmaFlushAllocation(), as required by Vulkan specification."]
    pub fn vmaUnmapMemory(allocator: VmaAllocator, allocation: VmaAllocation);
}
extern "C" {
    #[doc = " \\brief Flushes memory of given allocation.\n\nCalls `vkFlushMappedMemoryRanges()` for memory associated with given range of given allocation.\nIt needs to be called after writing to a mapped memory for memory types that are not `HOST_COHERENT`.\nUnmap operation doesn't do that automatically.\n\n- `offset` must be relative to the beginning of allocation.\n- `size` can be `VK_WHOLE_SIZE`. It means all memory from `offset` the the end of given allocation.\n- `offset` and `size` don't have to be aligned.\nThey are internally rounded down/up to multiply of `nonCoherentAtomSize`.\n- If `size` is 0, this call is ignored.\n- If memory type that the `allocation` belongs to is not `HOST_VISIBLE` or it is `HOST_COHERENT`,\nthis call is ignored.\n\nWarning! `offset` and `size` are relative to the contents of given `allocation`.\nIf you mean whole allocation, you can pass 0 and `VK_WHOLE_SIZE`, respectively.\nDo not pass allocation's offset as `offset`!!!\n\nThis function returns the `VkResult` from `vkFlushMappedMemoryRanges` if it is\ncalled, otherwise `VK_SUCCESS`."]
    pub fn vmaFlushAllocation(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        offset: VkDeviceSize,
        size: VkDeviceSize,
    ) -> VkResult;
}
extern "C" {
    #[doc = " \\brief Invalidates memory of given allocation.\n\nCalls `vkInvalidateMappedMemoryRanges()` for memory associated with given range of given allocation.\nIt needs to be called before reading from a mapped memory for memory types that are not `HOST_COHERENT`.\nMap operation doesn't do that automatically.\n\n- `offset` must be relative to the beginning of allocation.\n- `size` can be `VK_WHOLE_SIZE`. It means all memory from `offset` the the end of given allocation.\n- `offset` and `size` don't have to be aligned.\nThey are internally rounded down/up to multiply of `nonCoherentAtomSize`.\n- If `size` is 0, this call is ignored.\n- If memory type that the `allocation` belongs to is not `HOST_VISIBLE` or it is `HOST_COHERENT`,\nthis call is ignored.\n\nWarning! `offset` and `size` are relative to the contents of given `allocation`.\nIf you mean whole allocation, you can pass 0 and `VK_WHOLE_SIZE`, respectively.\nDo not pass allocation's offset as `offset`!!!\n\nThis function returns the `VkResult` from `vkInvalidateMappedMemoryRanges` if\nit is called, otherwise `VK_SUCCESS`."]
    pub fn vmaInvalidateAllocation(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        offset: VkDeviceSize,
        size: VkDeviceSize,
    ) -> VkResult;
}
extern "C" {
    #[doc = " \\brief Flushes memory of given set of allocations.\n\nCalls `vkFlushMappedMemoryRanges()` for memory associated with given ranges of given allocations.\nFor more information, see documentation of vmaFlushAllocation().\n\n\\param allocator\n\\param allocationCount\n\\param allocations\n\\param offsets If not null, it must point to an array of offsets of regions to flush, relative to the beginning of respective allocations. Null means all offsets are zero.\n\\param sizes If not null, it must point to an array of sizes of regions to flush in respective allocations. Null means `VK_WHOLE_SIZE` for all allocations.\n\nThis function returns the `VkResult` from `vkFlushMappedMemoryRanges` if it is\ncalled, otherwise `VK_SUCCESS`."]
    pub fn vmaFlushAllocations(
        allocator: VmaAllocator,
        allocationCount: u32,
        allocations: *const *mut VmaAllocation_T,
        offsets: *const VkDeviceSize,
        sizes: *const VkDeviceSize,
    ) -> VkResult;
}
extern "C" {
    #[doc = " \\brief Invalidates memory of given set of allocations.\n\nCalls `vkInvalidateMappedMemoryRanges()` for memory associated with given ranges of given allocations.\nFor more information, see documentation of vmaInvalidateAllocation().\n\n\\param allocator\n\\param allocationCount\n\\param allocations\n\\param offsets If not null, it must point to an array of offsets of regions to flush, relative to the beginning of respective allocations. Null means all offsets are zero.\n\\param sizes If not null, it must point to an array of sizes of regions to flush in respective allocations. Null means `VK_WHOLE_SIZE` for all allocations.\n\nThis function returns the `VkResult` from `vkInvalidateMappedMemoryRanges` if it is\ncalled, otherwise `VK_SUCCESS`."]
    pub fn vmaInvalidateAllocations(
        allocator: VmaAllocator,
        allocationCount: u32,
        allocations: *const *mut VmaAllocation_T,
        offsets: *const VkDeviceSize,
        sizes: *const VkDeviceSize,
    ) -> VkResult;
}
extern "C" {
    #[doc = " \\brief Maps the allocation temporarily if needed, copies data from specified host pointer to it, and flushes the memory from the host caches if needed.\n\n\\param allocator\n\\param pSrcHostPointer Pointer to the host data that become source of the copy.\n\\param dstAllocation   Handle to the allocation that becomes destination of the copy.\n\\param dstAllocationLocalOffset  Offset within `dstAllocation` where to write copied data, in bytes.\n\\param size            Number of bytes to copy.\n\nThis is a convenience function that allows to copy data from a host pointer to an allocation easily.\nSame behavior can be achieved by calling vmaMapMemory(), `memcpy()`, vmaUnmapMemory(), vmaFlushAllocation().\n\nThis function can be called only for allocations created in a memory type that has `VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT` flag.\nIt can be ensured e.g. by using #VMA_MEMORY_USAGE_AUTO and #VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT or\n#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT.\nOtherwise, the function will fail and generate a Validation Layers error.\n\n`dstAllocationLocalOffset` is relative to the contents of given `dstAllocation`.\nIf you mean whole allocation, you should pass 0.\nDo not pass allocation's offset within device memory block this parameter!"]
    pub fn vmaCopyMemoryToAllocation(
        allocator: VmaAllocator,
        pSrcHostPointer: *const ::std::os::raw::c_void,
        dstAllocation: VmaAllocation,
        dstAllocationLocalOffset: VkDeviceSize,
        size: VkDeviceSize,
    ) -> VkResult;
}
extern "C" {
    #[doc = " \\brief Invalidates memory in the host caches if needed, maps the allocation temporarily if needed, and copies data from it to a specified host pointer.\n\n\\param allocator\n\\param srcAllocation   Handle to the allocation that becomes source of the copy.\n\\param srcAllocationLocalOffset  Offset within `srcAllocation` where to read copied data, in bytes.\n\\param pDstHostPointer Pointer to the host memory that become destination of the copy.\n\\param size            Number of bytes to copy.\n\nThis is a convenience function that allows to copy data from an allocation to a host pointer easily.\nSame behavior can be achieved by calling vmaInvalidateAllocation(), vmaMapMemory(), `memcpy()`, vmaUnmapMemory().\n\nThis function should be called only for allocations created in a memory type that has `VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT`\nand `VK_MEMORY_PROPERTY_HOST_CACHED_BIT` flag.\nIt can be ensured e.g. by using #VMA_MEMORY_USAGE_AUTO and #VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT.\nOtherwise, the function may fail and generate a Validation Layers error.\nIt may also work very slowly when reading from an uncached memory.\n\n`srcAllocationLocalOffset` is relative to the contents of given `srcAllocation`.\nIf you mean whole allocation, you should pass 0.\nDo not pass allocation's offset within device memory block as this parameter!"]
    pub fn vmaCopyAllocationToMemory(
        allocator: VmaAllocator,
        srcAllocation: VmaAllocation,
        srcAllocationLocalOffset: VkDeviceSize,
        pDstHostPointer: *mut ::std::os::raw::c_void,
        size: VkDeviceSize,
    ) -> VkResult;
}
extern "C" {
    #[doc = " \\brief Checks magic number in margins around all allocations in given memory types (in both default and custom pools) in search for corruptions.\n\n\\param allocator\n\\param memoryTypeBits Bit mask, where each bit set means that a memory type with that index should be checked.\n\nCorruption detection is enabled only when `VMA_DEBUG_DETECT_CORRUPTION` macro is defined to nonzero,\n`VMA_DEBUG_MARGIN` is defined to nonzero and only for memory types that are\n`HOST_VISIBLE` and `HOST_COHERENT`. For more information, see [Corruption detection](@ref debugging_memory_usage_corruption_detection).\n\nPossible return values:\n\n- `VK_ERROR_FEATURE_NOT_PRESENT` - corruption detection is not enabled for any of specified memory types.\n- `VK_SUCCESS` - corruption detection has been performed and succeeded.\n- `VK_ERROR_UNKNOWN` - corruption detection has been performed and found memory corruptions around one of the allocations.\n`VMA_ASSERT` is also fired in that case.\n- Other value: Error returned by Vulkan, e.g. memory mapping failure."]
    pub fn vmaCheckCorruption(allocator: VmaAllocator, memoryTypeBits: u32) -> VkResult;
}
extern "C" {
    #[doc = " \\brief Begins defragmentation process.\n\n\\param allocator Allocator object.\n\\param pInfo Structure filled with parameters of defragmentation.\n\\param[out] pContext Context object that must be passed to vmaEndDefragmentation() to finish defragmentation.\n\\returns\n- `VK_SUCCESS` if defragmentation can begin.\n- `VK_ERROR_FEATURE_NOT_PRESENT` if defragmentation is not supported.\n\nFor more information about defragmentation, see documentation chapter:\n[Defragmentation](@ref defragmentation)."]
    pub fn vmaBeginDefragmentation(
        allocator: VmaAllocator,
        pInfo: *const VmaDefragmentationInfo,
        pContext: *mut VmaDefragmentationContext,
    ) -> VkResult;
}
extern "C" {
    #[doc = " \\brief Ends defragmentation process.\n\n\\param allocator Allocator object.\n\\param context Context object that has been created by vmaBeginDefragmentation().\n\\param[out] pStats Optional stats for the defragmentation. Can be null.\n\nUse this function to finish defragmentation started by vmaBeginDefragmentation()."]
    pub fn vmaEndDefragmentation(
        allocator: VmaAllocator,
        context: VmaDefragmentationContext,
        pStats: *mut VmaDefragmentationStats,
    );
}
extern "C" {
    #[doc = " \\brief Starts single defragmentation pass.\n\n\\param allocator Allocator object.\n\\param context Context object that has been created by vmaBeginDefragmentation().\n\\param[out] pPassInfo Computed information for current pass.\n\\returns\n- `VK_SUCCESS` if no more moves are possible. Then you can omit call to vmaEndDefragmentationPass() and simply end whole defragmentation.\n- `VK_INCOMPLETE` if there are pending moves returned in `pPassInfo`. You need to perform them, call vmaEndDefragmentationPass(),\nand then preferably try another pass with vmaBeginDefragmentationPass()."]
    pub fn vmaBeginDefragmentationPass(
        allocator: VmaAllocator,
        context: VmaDefragmentationContext,
        pPassInfo: *mut VmaDefragmentationPassMoveInfo,
    ) -> VkResult;
}
extern "C" {
    #[doc = " \\brief Ends single defragmentation pass.\n\n\\param allocator Allocator object.\n\\param context Context object that has been created by vmaBeginDefragmentation().\n\\param pPassInfo Computed information for current pass filled by vmaBeginDefragmentationPass() and possibly modified by you.\n\nReturns `VK_SUCCESS` if no more moves are possible or `VK_INCOMPLETE` if more defragmentations are possible.\n\nEnds incremental defragmentation pass and commits all defragmentation moves from `pPassInfo`.\nAfter this call:\n\n- Allocations at `pPassInfo[i].srcAllocation` that had `pPassInfo[i].operation ==` #VMA_DEFRAGMENTATION_MOVE_OPERATION_COPY\n(which is the default) will be pointing to the new destination place.\n- Allocation at `pPassInfo[i].srcAllocation` that had `pPassInfo[i].operation ==` #VMA_DEFRAGMENTATION_MOVE_OPERATION_DESTROY\nwill be freed.\n\nIf no more moves are possible you can end whole defragmentation."]
    pub fn vmaEndDefragmentationPass(
        allocator: VmaAllocator,
        context: VmaDefragmentationContext,
        pPassInfo: *mut VmaDefragmentationPassMoveInfo,
    ) -> VkResult;
}
extern "C" {
    #[doc = " \\brief Binds buffer to allocation.\n\nBinds specified buffer to region of memory represented by specified allocation.\nGets `VkDeviceMemory` handle and offset from the allocation.\nIf you want to create a buffer, allocate memory for it and bind them together separately,\nyou should use this function for binding instead of standard `vkBindBufferMemory()`,\nbecause it ensures proper synchronization so that when a `VkDeviceMemory` object is used by multiple\nallocations, calls to `vkBind*Memory()` or `vkMapMemory()` won't happen from multiple threads simultaneously\n(which is illegal in Vulkan).\n\nIt is recommended to use function vmaCreateBuffer() instead of this one."]
    pub fn vmaBindBufferMemory(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        buffer: VkBuffer,
    ) -> VkResult;
}
extern "C" {
    #[doc = " \\brief Binds buffer to allocation with additional parameters.\n\n\\param allocator\n\\param allocation\n\\param allocationLocalOffset Additional offset to be added while binding, relative to the beginning of the `allocation`. Normally it should be 0.\n\\param buffer\n\\param pNext A chain of structures to be attached to `VkBindBufferMemoryInfoKHR` structure used internally. Normally it should be null.\n\nThis function is similar to vmaBindBufferMemory(), but it provides additional parameters.\n\nIf `pNext` is not null, #VmaAllocator object must have been created with #VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT flag\nor with VmaAllocatorCreateInfo::vulkanApiVersion `>= VK_API_VERSION_1_1`. Otherwise the call fails."]
    pub fn vmaBindBufferMemory2(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        allocationLocalOffset: VkDeviceSize,
        buffer: VkBuffer,
        pNext: *const ::std::os::raw::c_void,
    ) -> VkResult;
}
extern "C" {
    #[doc = " \\brief Binds image to allocation.\n\nBinds specified image to region of memory represented by specified allocation.\nGets `VkDeviceMemory` handle and offset from the allocation.\nIf you want to create an image, allocate memory for it and bind them together separately,\nyou should use this function for binding instead of standard `vkBindImageMemory()`,\nbecause it ensures proper synchronization so that when a `VkDeviceMemory` object is used by multiple\nallocations, calls to `vkBind*Memory()` or `vkMapMemory()` won't happen from multiple threads simultaneously\n(which is illegal in Vulkan).\n\nIt is recommended to use function vmaCreateImage() instead of this one."]
    pub fn vmaBindImageMemory(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        image: VkImage,
    ) -> VkResult;
}
extern "C" {
    #[doc = " \\brief Binds image to allocation with additional parameters.\n\n\\param allocator\n\\param allocation\n\\param allocationLocalOffset Additional offset to be added while binding, relative to the beginning of the `allocation`. Normally it should be 0.\n\\param image\n\\param pNext A chain of structures to be attached to `VkBindImageMemoryInfoKHR` structure used internally. Normally it should be null.\n\nThis function is similar to vmaBindImageMemory(), but it provides additional parameters.\n\nIf `pNext` is not null, #VmaAllocator object must have been created with #VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT flag\nor with VmaAllocatorCreateInfo::vulkanApiVersion `>= VK_API_VERSION_1_1`. Otherwise the call fails."]
    pub fn vmaBindImageMemory2(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        allocationLocalOffset: VkDeviceSize,
        image: VkImage,
        pNext: *const ::std::os::raw::c_void,
    ) -> VkResult;
}
extern "C" {
    #[doc = " \\brief Creates a new `VkBuffer`, allocates and binds memory for it.\n\n\\param allocator\n\\param pBufferCreateInfo\n\\param pAllocationCreateInfo\n\\param[out] pBuffer Buffer that was created.\n\\param[out] pAllocation Allocation that was created.\n\\param[out] pAllocationInfo Optional. Information about allocated memory. It can be later fetched using function vmaGetAllocationInfo().\n\nThis function automatically:\n\n-# Creates buffer.\n-# Allocates appropriate memory for it.\n-# Binds the buffer with the memory.\n\nIf any of these operations fail, buffer and allocation are not created,\nreturned value is negative error code, `*pBuffer` and `*pAllocation` are null.\n\nIf the function succeeded, you must destroy both buffer and allocation when you\nno longer need them using either convenience function vmaDestroyBuffer() or\nseparately, using `vkDestroyBuffer()` and vmaFreeMemory().\n\nIf #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,\nVK_KHR_dedicated_allocation extension is used internally to query driver whether\nit requires or prefers the new buffer to have dedicated allocation. If yes,\nand if dedicated allocation is possible\n(#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated\nallocation for this buffer, just like when using\n#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.\n\n\\note This function creates a new `VkBuffer`. Sub-allocation of parts of one large buffer,\nalthough recommended as a good practice, is out of scope of this library and could be implemented\nby the user as a higher-level logic on top of VMA."]
    pub fn vmaCreateBuffer(
        allocator: VmaAllocator,
        pBufferCreateInfo: *const VkBufferCreateInfo,
        pAllocationCreateInfo: *const VmaAllocationCreateInfo,
        pBuffer: *mut VkBuffer,
        pAllocation: *mut VmaAllocation,
        pAllocationInfo: *mut VmaAllocationInfo,
    ) -> VkResult;
}
extern "C" {
    #[doc = " \\brief Creates a buffer with additional minimum alignment.\n\nSimilar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows to specify custom,\nminimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g.\nfor interop with OpenGL."]
    pub fn vmaCreateBufferWithAlignment(
        allocator: VmaAllocator,
        pBufferCreateInfo: *const VkBufferCreateInfo,
        pAllocationCreateInfo: *const VmaAllocationCreateInfo,
        minAlignment: VkDeviceSize,
        pBuffer: *mut VkBuffer,
        pAllocation: *mut VmaAllocation,
        pAllocationInfo: *mut VmaAllocationInfo,
    ) -> VkResult;
}
extern "C" {
    #[doc = " \\brief Creates a new `VkBuffer`, binds already created memory for it.\n\n\\param allocator\n\\param allocation Allocation that provides memory to be used for binding new buffer to it.\n\\param pBufferCreateInfo\n\\param[out] pBuffer Buffer that was created.\n\nThis function automatically:\n\n-# Creates buffer.\n-# Binds the buffer with the supplied memory.\n\nIf any of these operations fail, buffer is not created,\nreturned value is negative error code and `*pBuffer` is null.\n\nIf the function succeeded, you must destroy the buffer when you\nno longer need it using `vkDestroyBuffer()`. If you want to also destroy the corresponding\nallocation you can use convenience function vmaDestroyBuffer().\n\n\\note There is a new version of this function augmented with parameter `allocationLocalOffset` - see vmaCreateAliasingBuffer2()."]
    pub fn vmaCreateAliasingBuffer(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        pBufferCreateInfo: *const VkBufferCreateInfo,
        pBuffer: *mut VkBuffer,
    ) -> VkResult;
}
extern "C" {
    #[doc = " \\brief Creates a new `VkBuffer`, binds already created memory for it.\n\n\\param allocator\n\\param allocation Allocation that provides memory to be used for binding new buffer to it.\n\\param allocationLocalOffset Additional offset to be added while binding, relative to the beginning of the allocation. Normally it should be 0.\n\\param pBufferCreateInfo\n\\param[out] pBuffer Buffer that was created.\n\nThis function automatically:\n\n-# Creates buffer.\n-# Binds the buffer with the supplied memory.\n\nIf any of these operations fail, buffer is not created,\nreturned value is negative error code and `*pBuffer` is null.\n\nIf the function succeeded, you must destroy the buffer when you\nno longer need it using `vkDestroyBuffer()`. If you want to also destroy the corresponding\nallocation you can use convenience function vmaDestroyBuffer().\n\n\\note This is a new version of the function augmented with parameter `allocationLocalOffset`."]
    pub fn vmaCreateAliasingBuffer2(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        allocationLocalOffset: VkDeviceSize,
        pBufferCreateInfo: *const VkBufferCreateInfo,
        pBuffer: *mut VkBuffer,
    ) -> VkResult;
}
extern "C" {
    #[doc = " \\brief Destroys Vulkan buffer and frees allocated memory.\n\nThis is just a convenience function equivalent to:\n\n\\code\nvkDestroyBuffer(device, buffer, allocationCallbacks);\nvmaFreeMemory(allocator, allocation);\n\\endcode\n\nIt is safe to pass null as buffer and/or allocation."]
    pub fn vmaDestroyBuffer(allocator: VmaAllocator, buffer: VkBuffer, allocation: VmaAllocation);
}
extern "C" {
    #[doc = " Function similar to vmaCreateBuffer()."]
    pub fn vmaCreateImage(
        allocator: VmaAllocator,
        pImageCreateInfo: *const VkImageCreateInfo,
        pAllocationCreateInfo: *const VmaAllocationCreateInfo,
        pImage: *mut VkImage,
        pAllocation: *mut VmaAllocation,
        pAllocationInfo: *mut VmaAllocationInfo,
    ) -> VkResult;
}
extern "C" {
    #[doc = " Function similar to vmaCreateAliasingBuffer() but for images."]
    pub fn vmaCreateAliasingImage(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        pImageCreateInfo: *const VkImageCreateInfo,
        pImage: *mut VkImage,
    ) -> VkResult;
}
extern "C" {
    #[doc = " Function similar to vmaCreateAliasingBuffer2() but for images."]
    pub fn vmaCreateAliasingImage2(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        allocationLocalOffset: VkDeviceSize,
        pImageCreateInfo: *const VkImageCreateInfo,
        pImage: *mut VkImage,
    ) -> VkResult;
}
extern "C" {
    #[doc = " \\brief Destroys Vulkan image and frees allocated memory.\n\nThis is just a convenience function equivalent to:\n\n\\code\nvkDestroyImage(device, image, allocationCallbacks);\nvmaFreeMemory(allocator, allocation);\n\\endcode\n\nIt is safe to pass null as image and/or allocation."]
    pub fn vmaDestroyImage(allocator: VmaAllocator, image: VkImage, allocation: VmaAllocation);
}
extern "C" {
    #[doc = " \\brief Creates new #VmaVirtualBlock object.\n\n\\param pCreateInfo Parameters for creation.\n\\param[out] pVirtualBlock Returned virtual block object or `VMA_NULL` if creation failed."]
    pub fn vmaCreateVirtualBlock(
        pCreateInfo: *const VmaVirtualBlockCreateInfo,
        pVirtualBlock: *mut VmaVirtualBlock,
    ) -> VkResult;
}
extern "C" {
    #[doc = " \\brief Destroys #VmaVirtualBlock object.\n\nPlease note that you should consciously handle virtual allocations that could remain unfreed in the block.\nYou should either free them individually using vmaVirtualFree() or call vmaClearVirtualBlock()\nif you are sure this is what you want. If you do neither, an assert is called.\n\nIf you keep pointers to some additional metadata associated with your virtual allocations in their `pUserData`,\ndon't forget to free them."]
    pub fn vmaDestroyVirtualBlock(virtualBlock: VmaVirtualBlock);
}
extern "C" {
    #[doc = " \\brief Returns true of the #VmaVirtualBlock is empty - contains 0 virtual allocations and has all its space available for new allocations."]
    pub fn vmaIsVirtualBlockEmpty(virtualBlock: VmaVirtualBlock) -> VkBool32;
}
extern "C" {
    #[doc = " \\brief Returns information about a specific virtual allocation within a virtual block, like its size and `pUserData` pointer."]
    pub fn vmaGetVirtualAllocationInfo(
        virtualBlock: VmaVirtualBlock,
        allocation: VmaVirtualAllocation,
        pVirtualAllocInfo: *mut VmaVirtualAllocationInfo,
    );
}
extern "C" {
    #[doc = " \\brief Allocates new virtual allocation inside given #VmaVirtualBlock.\n\nIf the allocation fails due to not enough free space available, `VK_ERROR_OUT_OF_DEVICE_MEMORY` is returned\n(despite the function doesn't ever allocate actual GPU memory).\n`pAllocation` is then set to `VK_NULL_HANDLE` and `pOffset`, if not null, it set to `UINT64_MAX`.\n\n\\param virtualBlock Virtual block\n\\param pCreateInfo Parameters for the allocation\n\\param[out] pAllocation Returned handle of the new allocation\n\\param[out] pOffset Returned offset of the new allocation. Optional, can be null."]
    pub fn vmaVirtualAllocate(
        virtualBlock: VmaVirtualBlock,
        pCreateInfo: *const VmaVirtualAllocationCreateInfo,
        pAllocation: *mut VmaVirtualAllocation,
        pOffset: *mut VkDeviceSize,
    ) -> VkResult;
}
extern "C" {
    #[doc = " \\brief Frees virtual allocation inside given #VmaVirtualBlock.\n\nIt is correct to call this function with `allocation == VK_NULL_HANDLE` - it does nothing."]
    pub fn vmaVirtualFree(virtualBlock: VmaVirtualBlock, allocation: VmaVirtualAllocation);
}
extern "C" {
    #[doc = " \\brief Frees all virtual allocations inside given #VmaVirtualBlock.\n\nYou must either call this function or free each virtual allocation individually with vmaVirtualFree()\nbefore destroying a virtual block. Otherwise, an assert is called.\n\nIf you keep pointer to some additional metadata associated with your virtual allocation in its `pUserData`,\ndon't forget to free it as well."]
    pub fn vmaClearVirtualBlock(virtualBlock: VmaVirtualBlock);
}
extern "C" {
    #[doc = " \\brief Changes custom pointer associated with given virtual allocation."]
    pub fn vmaSetVirtualAllocationUserData(
        virtualBlock: VmaVirtualBlock,
        allocation: VmaVirtualAllocation,
        pUserData: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " \\brief Calculates and returns statistics about virtual allocations and memory usage in given #VmaVirtualBlock.\n\nThis function is fast to call. For more detailed statistics, see vmaCalculateVirtualBlockStatistics()."]
    pub fn vmaGetVirtualBlockStatistics(virtualBlock: VmaVirtualBlock, pStats: *mut VmaStatistics);
}
extern "C" {
    #[doc = " \\brief Calculates and returns detailed statistics about virtual allocations and memory usage in given #VmaVirtualBlock.\n\nThis function is slow to call. Use for debugging purposes.\nFor less detailed statistics, see vmaGetVirtualBlockStatistics()."]
    pub fn vmaCalculateVirtualBlockStatistics(
        virtualBlock: VmaVirtualBlock,
        pStats: *mut VmaDetailedStatistics,
    );
}
extern "C" {
    #[doc = " \\brief Builds and returns a null-terminated string in JSON format with information about given #VmaVirtualBlock.\n\\param virtualBlock Virtual block.\n\\param[out] ppStatsString Returned string.\n\\param detailedMap Pass `VK_FALSE` to only obtain statistics as returned by vmaCalculateVirtualBlockStatistics(). Pass `VK_TRUE` to also obtain full list of allocations and free spaces.\n\nReturned string must be freed using vmaFreeVirtualBlockStatsString()."]
    pub fn vmaBuildVirtualBlockStatsString(
        virtualBlock: VmaVirtualBlock,
        ppStatsString: *mut *mut ::std::os::raw::c_char,
        detailedMap: VkBool32,
    );
}
extern "C" {
    #[doc = " Frees a string returned by vmaBuildVirtualBlockStatsString()."]
    pub fn vmaFreeVirtualBlockStatsString(
        virtualBlock: VmaVirtualBlock,
        pStatsString: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " \\brief Builds and returns statistics as a null-terminated string in JSON format.\n\\param allocator\n\\param[out] ppStatsString Must be freed using vmaFreeStatsString() function.\n\\param detailedMap"]
    pub fn vmaBuildStatsString(
        allocator: VmaAllocator,
        ppStatsString: *mut *mut ::std::os::raw::c_char,
        detailedMap: VkBool32,
    );
}
extern "C" {
    pub fn vmaFreeStatsString(allocator: VmaAllocator, pStatsString: *mut ::std::os::raw::c_char);
}
